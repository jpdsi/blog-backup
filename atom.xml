<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Japan Developer Support Internet Team Blog</title>
  
  <subtitle>日本マイクロソフトの Azure Bot Service / Internet Information Services (IIS) / Internet Explorer / Microsoft Edge に関するサポート情報のブログです。</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://jpdsi.github.io/blog/"/>
  <updated>2020-11-25T00:44:03.300Z</updated>
  <id>https://jpdsi.github.io/blog/</id>
  
  <author>
    <name>Developer Support Internet Japan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>.NET Framework で TLS 1.1 および TLS 1.2 を有効化する方法 - まとめ -</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/</id>
    <published>2020-11-24T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:03.300Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本記事は Technet Blog の更新停止に伴い、もともとばらばらに存在していた記事を一つのブログに集約／移行したものです。<br>元の記事の最新の更新情報については、本内容をご参照ください。</p></blockquote><p>(※ 2018 年 10 月 11 日に Japan IE Support Team Blog に公開した情報をアーカイブする目的で、Microsoft 社員にて改めて公開しております。)</p><p>みなさん、こんにちは。</p><p>.NET Framework での TLS 1.1 および 1.2 対応について、以前 .NET Framework で TLS1.1 および 1.2 を有効化する方法 という記事を投稿しています。<br>しかしながら、記載の内容がわかりづらいこと、また、記事の公開以降に Update できていなかった点があるため、まとめとして本記事を作成しました。<br>今後のご対応の一助となれましたら大変うれしく思います。  </p><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><hr><p>本資料は下記の構成でまとめています。</p><ol><li>TLS 1.1 および 1.2 に対応するうえでの考え方  </li><li>Windows OS の TLS 1.1 および 1.2 への対応状況  </li><li>.NET Framework で利用される既定のプロトコル バージョン  </li><li>.NET Framework 3.5 で TLS 1.1 および 1.2 を利用できるようにするための更新プログラム  </li><li>.NET Framework 3.5 で TLS 1.1 および 1.2 を既定値にするための方法  </li><li>.NET Framework 4.5.2 で TLS 1.1 および 1.2 を既定値にするための方法  </li><li>.NET Framework のサポート状況  </li><li>各 OS ごとの対応方法  </li></ol><p>また、本資料と併せて下記の資料もご参考ください。</p><blockquote><p><a href="https://docs.microsoft.com/en-us/dotnet/framework/network-programming/tls" target="_blank" rel="noopener">Transport Layer Security (TLS) best practices with the .NET Framework</a><br>(日本語訳) <a href="https://docs.microsoft.com/ja-jp/dotnet/framework/network-programming/tls" target="_blank" rel="noopener">.NET Framework でのトランスポート層セキュリティ (TLS) のベスト プラクティス</a> </p></blockquote><h2 id="1-TLS-1-1-および-1-2-に対応するうえでの考え方"><a href="#1-TLS-1-1-および-1-2-に対応するうえでの考え方" class="headerlink" title="1. TLS 1.1 および 1.2 に対応するうえでの考え方"></a>1. TLS 1.1 および 1.2 に対応するうえでの考え方</h2><hr><p>.NET Framework で作成されたアプリケーションを TLS 1.2 (TLS 1.1) に対応させるには下記の点を考慮する必要があります。<br>ご利用の OS が TLS 1.1 および 1.2 を利用できるかどうか、また、アプリケーションで独自に設定しているかどうか、により必要な対応が異なります。<br>このため、まずは下記の観点で、ご利用対象の環境やアプリケーションについて理解することが第一歩となります。  </p><ul><li><span style="color: darkblue;">対象の環境は OS として TLS 1.2 (TLS 1.1) を利用できるかどうか</span>  </li><li><span style="color: darkblue;">アプリケーション側で ServicePointManager.SecurityProtocol プロパティにすでに明示的に設定しているものがないか</span>  </li><li><span style="color: darkblue;">アプリケーションがターゲットしている .NET Framework のバージョンはいくつか</span>  </li><li><span style="color: darkblue;">稼働対象の環境にインストールされている .NET Framework のバージョンはいくつか</span>  </li><li><span style="color: darkblue;">アプリケーションを改修することはできるか</span>  </li></ul><p>各ポイントの詳細については次項以降をご覧ください。  </p><h2 id="2-Windows-OS-の-TLS-1-1-および-1-2-への対応状況"><a href="#2-Windows-OS-の-TLS-1-1-および-1-2-への対応状況" class="headerlink" title="2. Windows OS の TLS 1.1 および 1.2 への対応状況"></a>2. Windows OS の TLS 1.1 および 1.2 への対応状況</h2><hr><p>ご利用対象の Windows OS 自体が TLS 1.1 および 1.2 を利用することができない場合には、.NET Framework 側でいくら対応しても TLS 1.1 および 1.2 に対応することはできません。<br>.NET Framework での対応の前に、<span style="color: red;"><strong>Windows OS 自体を TLS 1.1 および 1.2 を利用できるように構成する必要があります</strong></span>。</p><p><strong>！ご注意ください！</strong><br>Windows OS 自体が TLS 1.1 および 1.2 を利用することができない状態でアプリケーション側で TLS 1.1 および 1.2 が指定されると、アプリケーション実行時に例外が発生します。  </p><h3 id="Windows-Server-2008-SP2"><a href="#Windows-Server-2008-SP2" class="headerlink" title="Windows Server 2008 SP2"></a>Windows Server 2008 SP2</h3><p>既定の状態では OS として TLS 1.1 および 1.2 を<span style="color: red;"><strong>利用することができません</strong></span>。<br>.NET Framework での TLS 1.1 および 1.2 への対応の前に、事前に下記の更新プログラムを適用し、OS として TLS 1.1 および 1.2 を利用できるようにする必要があります。  </p><blockquote><p><a href="https://support.microsoft.com/ja-jp/help/4019276/update-to-add-support-for-tls-1-1-and-tls-1-2-in-windows" target="_blank" rel="noopener">Windows Server 2008 SP2、Windows Embedded POSReady 2009、および Windows Embedded Standard 2009 に TLS 1.1 および TLS 1.2 のサポートを追加する更新プログラム</a>  </p></blockquote><p>更新プログラム適用後、必要に応じて上記資料に記載のレジストリ値を設定します。  </p><pre><code>[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.1\Client]  &quot;DisabledByDefault&quot;=dword:00000001  [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Client]  &quot;DisabledByDefault&quot;=dword:00000001  [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.1\Server]  &quot;DisabledByDefault&quot;=dword:00000001  [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Server]  &quot;DisabledByDefault&quot;=dword:00000001  </code></pre><p><strong>設定のポイント</strong><br>クライアント OS として利用する場合 (任意のアプリケーションが別の Web サーバーに接続するような場合) には Client に設定します。<br>サーバー OS として利用する場合 (Web サーバーのように接続を待ち受けるような場合) には Server に設定します。  </p><h3 id="Windows-Server-2008-R2-Windows-7"><a href="#Windows-Server-2008-R2-Windows-7" class="headerlink" title="Windows Server 2008 R2 / Windows 7"></a>Windows Server 2008 R2 / Windows 7</h3><p>OS としては TLS 1.1 および 1.2 を利用できますが、アプリケーション側より明示的に TLS 1.1 もしくは 1.2 を利用する指定がない限り利用されません。<br>アプリケーション側からの指定がなくとも利用されるように構成するには、上記の Windows Server 2008 SP2 に記載したレジストリ値 (DisabledByDefault) を必要に応じて設定します。<br>(参考) <a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn786418(v=ws.11)" target="_blank" rel="noopener">TLS/SSL Settings</a>  </p><h3 id="Windows-Server-2012-Windows-8-1-以降"><a href="#Windows-Server-2012-Windows-8-1-以降" class="headerlink" title="Windows Server 2012 / Windows 8.1 以降"></a>Windows Server 2012 / Windows 8.1 以降</h3><p>OS として TLS 1.1 および 1.2 を利用でき、かつ、既定の状態で TLS 1.1 および 1.2 が利用されるように構成されています。<br>追加で必要な設定はありません。  </p><h2 id="3-NET-Framework-で利用される既定のプロトコル-バージョン"><a href="#3-NET-Framework-で利用される既定のプロトコル-バージョン" class="headerlink" title="3. .NET Framework で利用される既定のプロトコル バージョン"></a>3. .NET Framework で利用される既定のプロトコル バージョン</h2><hr><p>.NET Framework では、HttpWebRequest クラスなどを利用した通信において ServicePointManager.SecurityProtocol プロパティに指定されたプロトコル バージョンが利用されます。<br>プログラム上で明示的に指定されている場合は指定されたプロトコル バージョンが利用されますが、指定されていない場合に利用される既定のプロトコル バージョンは下記のとおりです。<br>.NET Framework の各バージョンごとに、TLS 1.1 および 1.2 への対応状況と併せてまとめました。  </p><h3 id="NET-Framework-3-5-3-5-1"><a href="#NET-Framework-3-5-3-5-1" class="headerlink" title=".NET Framework 3.5 (3.5.1)"></a>.NET Framework 3.5 (3.5.1)</h3><p>既定では TLS 1.1 および 1.2 は未対応<br>プロパティの既定値は SSL 3.0 および TLS 1.0  </p><h3 id="NET-Framework-4-5-2"><a href="#NET-Framework-4-5-2" class="headerlink" title=".NET Framework 4.5.2"></a>.NET Framework 4.5.2</h3><p>TLS 1.1 / TLS 1.2 に対応済み<br>プロパティの既定値は SSL 3.0 および TLS 1.0  </p><h3 id="NET-Framework-4-6-x"><a href="#NET-Framework-4-6-x" class="headerlink" title=".NET Framework 4.6.x"></a>.NET Framework 4.6.x</h3><p>TLS 1.1 / TLS 1.2 に対応済み<br>プロパティの既定値は TLS 1.0、1.1 および 1.2  </p><h3 id="NET-Framework-4-7-x"><a href="#NET-Framework-4-7-x" class="headerlink" title=".NET Framework 4.7.x"></a>.NET Framework 4.7.x</h3><p>TLS 1.1 / TLS 1.2 に対応済み<br>プロパティの既定値は SystemDefault となり、OS の TLS の設定状態に依存する  </p><h3 id="NET-Framework-4-8-x"><a href="#NET-Framework-4-8-x" class="headerlink" title=".NET Framework 4.8.x"></a>.NET Framework 4.8.x</h3><p>TLS 1.1 / TLS 1.2 に対応済み<br>プロパティの既定値は SystemDefault となり、OS の TLS の設定状態に依存する  </p><h2 id="4-NET-Framework-3-5-で-TLS-1-1-および-1-2-を利用できるようにするための更新プログラム"><a href="#4-NET-Framework-3-5-で-TLS-1-1-および-1-2-を利用できるようにするための更新プログラム" class="headerlink" title="4. .NET Framework 3.5 で TLS 1.1 および 1.2 を利用できるようにするための更新プログラム"></a>4. .NET Framework 3.5 で TLS 1.1 および 1.2 を利用できるようにするための更新プログラム</h2><hr><p>.NET Framework 3.5 は既定の状態では TLS 1.1 および 1.2 を利用することができません。<br>.NET Framework 3.5 で TLS 1.1 および 1.2 を利用できるようにするために下記の更新プログラムを適用する必要があります。<br>※ 下記更新プログラムはそれ以降の更新プログラムで置き換えられていますので、セキュリティの観点では『Windows 10 および Windows Server 2016 の場合は OS 向けの最新のロールアップ』を、『それ以外の OS では .NET Framework 向けの最新の品質ロールアップ』を適用することをおすすめします。</p><p><strong>！ご注意ください！</strong><br>更新プログラムを適用しない状態でアプリケーション側で TLS 1.1 および 1.2 が指定されると、アプリケーション実行時に例外が発生します。  </p><h3 id="Windows-Server-2008"><a href="#Windows-Server-2008" class="headerlink" title="Windows Server 2008"></a>Windows Server 2008</h3><p><a href="https://support.microsoft.com/en-us/help/3154517/support-for-tls-system-default-versions-included-in-the-net-framework" target="_blank" rel="noopener">Support for TLS System Default Versions included in the .NET Framework 2.0 SP2 on Windows Vista SP2 and Server 2008 SP2</a>  </p><h3 id="Windows-Server-2008-R2-Windows-7-1"><a href="#Windows-Server-2008-R2-Windows-7-1" class="headerlink" title="Windows Server 2008 R2 / Windows 7"></a>Windows Server 2008 R2 / Windows 7</h3><p><a href="https://support.microsoft.com/en-us/help/3154518/support-for-tls-system-default-versions-included-in-the-net-framework" target="_blank" rel="noopener">Support for TLS System Default Versions included in the .NET Framework 3.5.1 on Windows 7 SP1 and Server 2008 R2 SP1</a>  </p><h3 id="Windows-Server-2012"><a href="#Windows-Server-2012" class="headerlink" title="Windows Server 2012"></a>Windows Server 2012</h3><p><a href="https://support.microsoft.com/en-us/help/3154519/support-for-tls-system-default-versions-included-in-the-net-framework" target="_blank" rel="noopener">Support for TLS System Default Versions included in the .NET Framework 3.5 on Windows Server 2012</a>  </p><h3 id="Windows-Server-2012-R2-Windows-8-1"><a href="#Windows-Server-2012-R2-Windows-8-1" class="headerlink" title="Windows Server 2012 R2 / Windows 8.1"></a>Windows Server 2012 R2 / Windows 8.1</h3><p><a href="https://support.microsoft.com/en-us/help/3154520/support-for-tls-system-default-versions-included-in-the-net-framework" target="_blank" rel="noopener">Support for TLS System Default Versions included in the .NET Framework 3.5 on Windows 8.1 and Windows Server 2012 R2</a><br>※ 更新プログラムの適用には Windows 8.1 Update / Windows Server 2012 R2 Update (KB2919355) が事前に適用されている必要があります  </p><h3 id="Windows-10-v1507-LTSC"><a href="#Windows-10-v1507-LTSC" class="headerlink" title="Windows 10 v1507 (LTSC)"></a>Windows 10 v1507 (LTSC)</h3><p>Windows 10 v1507 環境向けに公開されている更新プログラムを適用します。<br>※ 本記事執筆時点で、最も古い更新プログラムは下記の 2016 年 10 月に公開された更新プログラムです。下記以降の更新プログラムの適用をご検討ください。<br><a href="https://support.microsoft.com/ja-jp/help/4001772/windows-10-update-kb3192440" target="_blank" rel="noopener">2016 年 10 月 11 日 — KB3192440 (OS ビルド 10240.17146)</a>  </p><h3 id="Windows-10-v1607-LTSC-Windows-Server-2016"><a href="#Windows-10-v1607-LTSC-Windows-Server-2016" class="headerlink" title="Windows 10 v1607 (LTSC) / Windows Server 2016"></a>Windows 10 v1607 (LTSC) / Windows Server 2016</h3><p>下記のいずれかの更新プログラム以降で対応されています。<br><a href="https://support.microsoft.com/ja-jp/help/4004253/windows-10-update-kb3201845" target="_blank" rel="noopener">2016 年 12 月 9 日 — KB3201845 (OS ビルド 14393.479)</a><br><a href="https://support.microsoft.com/ja-jp/help/4004227/windows-10-update-kb3206632" target="_blank" rel="noopener">2016 年 12 月 13 日 — KB3206632 (OS ビルド 14393.576)</a></p><h3 id="Windows-10-v1703-Windows-Server-2019-以降"><a href="#Windows-10-v1703-Windows-Server-2019-以降" class="headerlink" title="Windows 10 v1703 / Windows Server 2019 以降"></a>Windows 10 v1703 / Windows Server 2019 以降</h3><p>.NET Framework 3.5 の機能を有効化した時点ですでに対応されています。<br>追加で適用が必要な更新プログラムはありません。  </p><h2 id="5-NET-Framework-3-5-で-TLS-1-1-および-1-2-を既定値にするための方法"><a href="#5-NET-Framework-3-5-で-TLS-1-1-および-1-2-を既定値にするための方法" class="headerlink" title="5. .NET Framework 3.5 で TLS 1.1 および 1.2 を既定値にするための方法"></a>5. .NET Framework 3.5 で TLS 1.1 および 1.2 を既定値にするための方法</h2><hr><p>.NET Framework 3.5 は、SSL 3.0 および TLS 1.0 が既定で利用されるプロトコル バージョンです。<br>既定値を変更するには、Windows OS 側で TLS 1.1 および 1.2 が利用されるよう構成し、かつ、.NET Framework 3.5 で TLS 1.1 および 1.2 を利用できるようにするための更新プログラムを適用したうえで各資料に記載の下記のレジストリ値を設定します。  </p><p>下記のレジストリ値が設定されると Windows OS 側で構成しているプロトコル バージョンに従うようになります。<br>Windows OS 側で TLS 1.1 および 1.2 が利用されるよう構成することで、.NET Framework 3.5 で利用されるプロトコル バージョンも TLS 1.0、TLS 1.1 および TLS 1.2 に変更されます。  </p><pre><code>[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v2.0.50727]  &quot;SystemDefaultTlsVersions&quot;=dword:00000001  </code></pre><p>64 ビット OS の環境の場合は下記にも設定します。</p><pre><code>[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\.NETFramework\v2.0.50727]  &quot;SystemDefaultTlsVersions&quot;=dword:00000001  </code></pre><p><strong>設定のポイント</strong><br>プログラム上で ServicePointManager.SecurityProtocol プロパティに明示的に任意のプロトコル バージョンを指定している場合は、上記のレジストリ値の設定の有無にかかわらずプログラムで指定したプロトコル バージョンが利用されます。  </p><h2 id="6-NET-Framework-4-5-2-で-TLS-1-1-および-1-2-を既定値にするための方法"><a href="#6-NET-Framework-4-5-2-で-TLS-1-1-および-1-2-を既定値にするための方法" class="headerlink" title="6. .NET Framework 4.5.2 で TLS 1.1 および 1.2 を既定値にするための方法"></a>6. .NET Framework 4.5.2 で TLS 1.1 および 1.2 を既定値にするための方法</h2><hr><p>.NET Framework 4.5.2 は、SSL 3.0 および TLS 1.0 が既定で利用されるプロトコル バージョンです。<br>既定値を変更するには、下記のセキュリティ アドバイザリー 2960358 で公開されている更新プログラムを適用します。<br>※ 下記更新プログラムはそれ以降の更新プログラムで置き換えられていますので、セキュリティの観点では『Windows 10 および Windows Server 2016 の場合は OS 向けの最新のロールアップ』を、『それ以外の OS では .NET Framework 向けの最新の品質ロールアップ』を適用することをおすすめします。  </p><blockquote><p><a href="https://docs.microsoft.com/en-us/security-updates/securityadvisories/2015/2960358" target="_blank" rel="noopener">Microsoft Security Advisory 2960358</a><br>(日本語訳) <a href="https://docs.microsoft.com/ja-jp/security-updates/securityadvisories/2015/2960358" target="_blank" rel="noopener">マイクロソフト セキュリティ アドバイザリ 2960358</a>  </p></blockquote><p>上記のセキュリティ アドバイザリーを適用すると下記のレジストリ値が構成され、.NET Framework 4.5.2 で利用されるプロトコル バージョンが TLS 1.0、TLS 1.1 および TLS 1.2 に変更されます。<br>念のためレジストリ値が構成されているか確認し、万が一構成されていない場合は手動で構成します。  </p><pre><code>[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v4.0.30319]  &quot;SchUseStrongCrypto&quot;=dword:00000001  </code></pre><p>64 ビット OS 環境の場合は下記にも設定します。</p><pre><code>[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\.NETFramework\v4.0.30319]  &quot;SchUseStrongCrypto&quot;=dword:00000001  </code></pre><p><strong>設定のポイント</strong><br><span style="color: red;">プログラム上で ServicePointManager.SecurityProtocol プロパティに明示的に任意のプロトコル バージョンを指定している場合は、上記のレジストリ値の設定の有無にかかわらずプログラムで指定したプロトコル バージョンが利用されます。</span>  </p><h2 id="7-NET-Framework-のサポート状況"><a href="#7-NET-Framework-のサポート状況" class="headerlink" title="7. .NET Framework のサポート状況"></a>7. .NET Framework のサポート状況</h2><p><span style="color: red;">.NET Framework 4.x 系は、4.5.2 以降がサポート対象です。</span><br>稼働対象の環境にインストールするバージョンは可能な限り最新のバージョンとすることをご検討ください。  </p><blockquote><p><a href="https://blogs.msdn.microsoft.com/visualstudio_jpn/2015/10/18/net-framework-201510/" target="_blank" rel="noopener">.NET Framework サポート ライフサイクル ポリシーについて (2015 年 10 月)</a><br><a href="https://blogs.msdn.microsoft.com/jpvsblog/2015/07/22/net-framework-4-12388/" target="_blank" rel="noopener">.NET Framework 4 を対象に作成したアプリケーションのサポートについて</a>  </p></blockquote><h3 id="各-OS-上での-NET-Framework-の既定のバージョン"><a href="#各-OS-上での-NET-Framework-の既定のバージョン" class="headerlink" title="各 OS 上での .NET Framework の既定のバージョン"></a>各 OS 上での .NET Framework の既定のバージョン</h3><p>OS ごとに既定でインストールされている .NET Framework のバージョンは下記の資料をご覧ください。<br>OS によってはクリーンインストールした状態ですでにサポートが終了している状況もあり得るため、インストールすることのできる最新バージョンへの更新をご検討ください。  </p><blockquote><p><a href="https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/versions-and-dependencies" target="_blank" rel="noopener">.NET Framework Versions and Dependencies</a><br>(日本語訳) <a href="https://docs.microsoft.com/ja-jp/dotnet/framework/migration-guide/versions-and-dependencies" target="_blank" rel="noopener">.NET Framework のバージョンおよび依存関係</a>  </p></blockquote><blockquote><p><a href="https://docs.microsoft.com/en-us/dotnet/framework/install/" target="_blank" rel="noopener">Installation guide</a><br>(日本語訳) <a href="https://docs.microsoft.com/ja-jp/dotnet/framework/install/" target="_blank" rel="noopener">インストール ガイド</a>  </p></blockquote><h3 id="各-OS-上でサポートされるバージョン"><a href="#各-OS-上でサポートされるバージョン" class="headerlink" title="各 OS 上でサポートされるバージョン"></a>各 OS 上でサポートされるバージョン</h3><p>各 OS ごとにサポートされているバージョンは下表のとおりです。  </p><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/dotnet-framework-versions-dependencies.png" class="">  <h2 id="8-各-OS-ごとの対応方法"><a href="#8-各-OS-ごとの対応方法" class="headerlink" title="8. 各 OS ごとの対応方法"></a>8. 各 OS ごとの対応方法</h2><hr><p>上記までの内容を踏まえたうえでの各 OS ごとの対応方法について下記にまとめました。<br>なお、.NET Framework 3.5(.1) は、事前に <span style="color: red;"><strong>TLS 1.1 および TLS 1.2 に対応するための更新プログラムが適用されていることが前提</strong></span> です。<br>また、Windows Server 2008 は、事前に <span style="color: red;"><strong>OS 向けの TLS 1.1 および 1.2 に対応するための更新プログラムが適用されていることが前提</strong></span> です。  </p><h3 id="各-OS-共通"><a href="#各-OS-共通" class="headerlink" title="各 OS 共通"></a>各 OS 共通</h3><p>何度も記載していますが、ServicePointManager.SecurityProtocol プロパティに明示的にプロトコル バージョンを指定している場合には、当プロパティに指定したプロトコル バージョンが利用されます。<br>下表は当プロパティに TLS 1.2 を設定した場合の対応表になります。  </p><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/os_common.png" class="">  <p>ServicePointManager.SecurityProtocol プロパティに明示的に指定していない場合の各 OS ごとの対応表は下記のとおりです。  </p><h3 id="Windows-Server-2008-1"><a href="#Windows-Server-2008-1" class="headerlink" title="Windows Server 2008"></a>Windows Server 2008</h3><p><strong>※ 前提条件 ※</strong><br>Windows Server 2008 は、既定の状態では OS として TLS 1.1 および 1.2 を利用することができません。<br>事前に <span style="color: red;"><strong>TLS 1.1 および 1.2 を利用できるようにするための更新プログラムの適用が必須</strong></span> です。  </p><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/windows-server-2008.png" class="">  <h3 id="Windows-Server-2008-R2-Windows-7-2"><a href="#Windows-Server-2008-R2-Windows-7-2" class="headerlink" title="Windows Server 2008 R2 / Windows 7"></a>Windows Server 2008 R2 / Windows 7</h3><p><strong>※ 前提条件 ※</strong><br>Windows Server 2008 R2 / Windows 7 は OS としては TLS 1.1 および 1.2 を利用できますが、アプリケーション側より明示的に TLS 1.1 もしくは 1.2 を利用する指定がない限り利用されません。<br>必要に応じて <span style="color: red;"><strong>アプリケーション側からの指定がなくとも TLS 1.1 および 1.2 が利用されるためのレジストリ値を設定します</strong></span>。  </p><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/windows-7-windows-server-2008r2.png" class="">  <h3 id="Windows-Server-2012-1"><a href="#Windows-Server-2012-1" class="headerlink" title="Windows Server 2012"></a>Windows Server 2012</h3><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/windows-server-2012.png" class="">  <h3 id="Windows-Server-2012-R2-Windows-8-1-1"><a href="#Windows-Server-2012-R2-Windows-8-1-1" class="headerlink" title="Windows Server 2012 R2 / Windows 8.1"></a>Windows Server 2012 R2 / Windows 8.1</h3><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/windows-81-windows-server-2012r2.png" class="">  <h3 id="Windows-10-v1507-LTSC-2015"><a href="#Windows-10-v1507-LTSC-2015" class="headerlink" title="Windows 10 v1507 (LTSC 2015)"></a>Windows 10 v1507 (LTSC 2015)</h3><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/windows-10-1507.png" class="">  <h3 id="Windows-10-v1607-LTSC-2016-Windows-Server-2016"><a href="#Windows-10-v1607-LTSC-2016-Windows-Server-2016" class="headerlink" title="Windows 10 v1607 (LTSC 2016) / Windows Server 2016"></a>Windows 10 v1607 (LTSC 2016) / Windows Server 2016</h3><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/windows-10-1607-windows-server-2016.png" class="">  <h3 id="Windows-10-v1803"><a href="#Windows-10-v1803" class="headerlink" title="Windows 10 v1803"></a>Windows 10 v1803</h3><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/windows-10-1803.png" class="">  <h3 id="Windows-10-v1809-LTSC-2019-Windows-Server-2019"><a href="#Windows-10-v1809-LTSC-2019-Windows-Server-2019" class="headerlink" title="Windows 10 v1809 (LTSC 2019) / Windows Server 2019"></a>Windows 10 v1809 (LTSC 2019) / Windows Server 2019</h3><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/windows-10-1809-windows-server-2019.png" class="">  <h3 id="Windows-10-v1903-v1909-v2004-v20H2"><a href="#Windows-10-v1903-v1909-v2004-v20H2" class="headerlink" title="Windows 10 v1903 / v1909 / v2004 / v20H2"></a>Windows 10 v1903 / v1909 / v2004 / v20H2</h3><img src="/blog/internet-explorer-microsoft-edge/dotnet-framework-tls12/windows-10-1903-to-20H2.png" class="">  <p>いかがでしょうか。<br>本記事が今後のご対応のお役に立てますと幸いです。</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本記事は Technet Blog の更新停止に伴い、もともとばらばらに存在していた記事を一つのブログに集約／移行したものです。&lt;br&gt;元の記事の最新の更新情報については、本内容をご参照ください。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(※ 2
      
    
    </summary>
    
    
    
      <category term=".NET Framewrork" scheme="https://jpdsi.github.io/blog/tags/NET-Framewrork/"/>
    
      <category term="TLS" scheme="https://jpdsi.github.io/blog/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>gRPC で動く CLI チャットアプリを ASP.NET Core で実装してみよう！</title>
    <link href="https://jpdsi.github.io/blog/web-apps/GrpcChatOnAspNetCore/"/>
    <id>https://jpdsi.github.io/blog/web-apps/GrpcChatOnAspNetCore/</id>
    <published>2020-09-14T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:05.479Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。<br>Developer Support Internet チーム にてインターンをしている尾崎耀一と申します！</p><p>今回は ASP.NET Core を用いて、 gRPC で動く CLI （コマンドライン）でチャットができるアプリを作る方法を紹介します。<br>本記事を通じて、 ASP.NET Core を用いた gRPC サービスの開発が簡単にできることがわかると思います。<br>皆様の開発の一助になると幸いです。</p><p>まずはチャット アプリを作る前に ASP.NET Core についてご紹介します。</p><hr><h2 id="ASP-NET-Core-について"><a href="#ASP-NET-Core-について" class="headerlink" title="ASP.NET Core について"></a>ASP.NET Core について</h2><p>ASP.NET Core はクロスプラットフォームで動作するウェブアプリケーションフレームワークです。</p><p>ASP.NET Core を用いることで簡単にウェブアプリを開発することができます。加えて、 ASP.NET Core はクロスプラットフォームに対応しているので、 Windows/macOS/Linux 上で開発・実行することができます。</p><p>ASP.NET Core はオープンソースで開発が進められており、 ASP.NET Core コミュニティーは大きく成長しています。</p><p>ASP.NET Core はモダンなウェブ開発をフレームワークとしてサポートしています。テストが容易に実行できるようなアーキテクチャを採用しており、クラウドへのデプロイなども想定し Visual Studio などのエディタも用意されています。</p><p>また、最新の技術にも対応しています。 例えば、gRPC によるリモート プロシージャ コールのサポートや <a href="https://webassembly.org/" target="_blank" rel="noopener">WebAssemby</a> によって SAP（Single Page Application）を C# で開発する <a href="https://docs.microsoft.com/ja-jp/aspnet/core/blazor/?view=aspnetcore-3.1" target="_blank" rel="noopener">Blazor</a> というフレームワークもサポートしています。</p><p>公式ドキュメントにもあるように、ASP.NET Core には次のような利点があります。</p><blockquote><ul><li>Web UI と Web API を構築するプロセスの統一。</li><li>テストの容易性を考慮したアーキテクチャ。</li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/razor-pages/?view=aspnetcore-3.1" target="_blank" rel="noopener">Razor Pages</a> により、ページ コーディングに重点を置いたシナリオがより簡略化され、その生産性が高められます。</li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/blazor/?view=aspnetcore-3.1" target="_blank" rel="noopener">Blazor</a> により、ブラウザー内で JavaScript と共に C# を使用できます。 すべて .NET で記述された、サーバー側とクライアント側アプリのロジックを共有します。</li><li>Windows、macOS、Linux 上で開発および実行できること。</li><li>オープン ソースで<a href="https://live.asp.net/" target="_blank" rel="noopener">コミュニティ重視</a>。</li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/blazor/?view=aspnetcore-3.1" target="_blank" rel="noopener">最新のクライアント側フレームワーク</a>と開発ワークフローの統合。</li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/grpc/?view=aspnetcore-3.1" target="_blank" rel="noopener">gRPC</a> を使用したリモート プロシージャ コール (RPC) サービスのホストのサポート。</li><li>クラウド対応で環境ベースの<a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1" target="_blank" rel="noopener">構成システム</a>。</li><li>組み込まれている<a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1" target="_blank" rel="noopener">依存性の注入</a>。</li><li>軽量で<a href="https://github.com/aspnet/benchmarks" target="_blank" rel="noopener">高パフォーマンス</a>のモジュール化された HTTP 要求パイプライン。</li><li>次がホストする機能です。<ul><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.1" target="_blank" rel="noopener">Kestrel</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/host-and-deploy/iis/?view=aspnetcore-3.1" target="_blank" rel="noopener">IIS</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/servers/httpsys?view=aspnetcore-3.1" target="_blank" rel="noopener">HTTP.sys</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-3.1" target="_blank" rel="noopener">Nginx</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/host-and-deploy/linux-apache?view=aspnetcore-3.1" target="_blank" rel="noopener">Apache</a></li><li><a href="https://docs.microsoft.com/ja-jp/aspnet/core/host-and-deploy/docker/?view=aspnetcore-3.1" target="_blank" rel="noopener">Docker</a></li></ul></li><li><a href="https://docs.microsoft.com/ja-jp/dotnet/standard/choosing-core-framework-server#side-by-side-net-versions-per-application-level" target="_blank" rel="noopener">side-by-side でのバージョン管理</a>。</li><li>最新の Web 開発を簡単にするツール。<blockquote><p>ASP.NET Core 公式ドキュメントより抜粋</p></blockquote></li></ul></blockquote><p>参考：<a href="https://docs.microsoft.com/ja-jp/aspnet/core/?view=aspnetcore-3.1" target="_blank" rel="noopener">ASP.NET Core 公式ドキュメント</a><br>参考：<a href="https://docs.microsoft.com/ja-jp/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-3.1" target="_blank" rel="noopener">ASP.NET Coreについて</a></p><h2 id="gRPC-について"><a href="#gRPC-について" class="headerlink" title="gRPC について"></a>gRPC について</h2><p>次に、 gRPC についてご紹介します。</p><p>gRPC は言語に依存しない高性能なリモート プロシージャ コール（RPC）フレームワークです。</p><p>gRPC を用いることで、やり取りされるデータのシリアライズ・デシリアライズや通信部分はフレームワーク側がカバーしてくれるため、アプリケーション開発者はプロシージャを呼び出すクライアントと呼び出されるサーバプロシージャのみを実装すれば良いということになります。</p><p>gRPC ではデータのシリアライズに Protocol Buffers をデフォルトでは採用しています。Protocol Buffers はサービス間のインタフェースを定義する言語とそれを書くプログラミング言語のプログラムにコンパイルするツール群を含んでいます。Protocol Buffers では、公開する関数 (リモートプロシージャ) や、やり取りするデータの型を <code>.proto</code> ファイルにて定義し、 <code>.proto</code> ファイルからデータをシリアライズするプログラムのソースコードを自動生成することができ、対応する言語も C++/C#/Go/Java/Python etc… と豊富です。サービス間のインタフェースをコードとして静的に定義することが可能であるため、ソースコードの生成のみならず、ドキュメントの自動生成などもできます。</p><p>また、gRPC には次のような特徴を持ちます。</p><ul><li>Protocol Buffers を内部で用いているので他言語でのサーバ・クライアントの開発が可能です。</li><li>HTTP/2 による通信を行います。ゆえに双方向ストリーミング通信もサポートしています。</li><li>その手軽さと利便性から Netflix などでも採用されており、今後もユースケースの増加が見込まれます。</li></ul><img src="/blog/web-apps/GrpcChatOnAspNetCore/grpc.png" class=""><p>参考：<a href="https://grpc.io/" target="_blank" rel="noopener">gRPC 公式サイト</a><br>参考：<a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener">Protocol Buffers 公式サイト</a></p><h2 id="Hands-on：CLI-Chat-アプリ"><a href="#Hands-on：CLI-Chat-アプリ" class="headerlink" title="Hands-on：CLI Chat アプリ"></a>Hands-on：CLI Chat アプリ</h2><p>今回は gRPC で通信する Chat サーバと Chat クライアントを ASP.NET Core を用いて実装します。さらに gRPC で通信する Chat クライアントを C# とは別の言語（今回は go 言語）で実装し、 gRPC の「プログラミング言語に依存しない」という特徴も確認します。 ASP.NET Core を用いた gRPC サービスの開発が非常に容易であることも実感できると思います。</p><h3 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h3><p>以下の内容は以下の環境にて検証しました。</p><ul><li>OS：Windows 10 Enterprise バージョン 1903</li><li>IDE：Visual Studio 2019</li><li>Platform：.NET Core 3.1.401</li></ul><p>Visual Studio のインストールは<a href="https://docs.microsoft.com/ja-jp/visualstudio/install/install-visual-studio?view=vs-2019" target="_blank" rel="noopener">こちら</a>を参考にしてください。</p><h3 id="今回作成する-Chat-サービスのインターフェース定義"><a href="#今回作成する-Chat-サービスのインターフェース定義" class="headerlink" title="今回作成する Chat サービスのインターフェース定義"></a>今回作成する Chat サービスのインターフェース定義</h3><p>今回の Chat サービスでは、<code>ChatRoom</code> が一つあり、そこにユーザが <code>Join</code> することで <code>Message</code> のやり取りができるものを考えます。</p><p>ユーザは一度 <code>ChatRoom</code> に <code>Join</code> すると、その <code>ChatRoom</code> 内での他のユーザの発言を知る必要があるため、Chat サーバ-Chatクライアント間には <code>Message</code> の流れる双方向ストリームが必要になります。</p><p>これを、 <code>chat.proto</code> として記述すると以下のようになります。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package Chat;</span><br><span class="line"></span><br><span class="line">service ChatRoom &#123;</span><br><span class="line">  rpc join (stream Message) returns (stream Message) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Message &#123;</span><br><span class="line">  string user &#x3D; 1;</span><br><span class="line">  string text &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gRPC-で通信する-Chat-サーバを-ASP-NET-Core-で実装する"><a href="#gRPC-で通信する-Chat-サーバを-ASP-NET-Core-で実装する" class="headerlink" title="gRPC で通信する Chat サーバを ASP.NET Core で実装する"></a>gRPC で通信する Chat サーバを ASP.NET Core で実装する</h3><p>まず Visual Studio を立ち上げ、「新しいプロジェクトの作成」から gRPC サービスのテンプレートを選択し、テンプレートプロジェクト（プロジェクト名： <code>GrpcChatServer</code> ）を作成します。</p><p>このとき、出来上がるテンプレートプロジェクトは、<a href="https://docs.microsoft.com/ja-jp/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-3.1&tabs=visual-studio" target="_blank" rel="noopener">公式ドキュメント</a>のチュートリアルにおける、「 Greeter サービス」と同じものです。このテンプレートプロジェクトには、 <code>Grpc.AspNetCore (2.31.0)</code> という ASP.NET Core で gRPC アプリケーションを作成するために必要なパッケージがインストール済みです。</p><p>このテンプレートに手を加えて、 Chat サービスを実装していきます。</p><p>まず最初に、 <code>chat.proto</code> を <code>GrpcChatServer/Protos</code> にコピーします。続けて、 <code>GrpcChatServer.csproj</code> に下記　<code>&lt;ItemGroup&gt;</code> を追加します。ここで　<code>GrpcServices=&quot;Server&quot;</code> と記載することで、 <code>.proto</code> ファイルから gRPC サーバ用のコードが自動生成されることになります。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Protobuf</span> <span class="attr">Include</span>=<span class="string">"Protos\*.proto"</span> <span class="attr">GrpcServices</span>=<span class="string">"Server"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>次に、 <code>ChatRoom</code> クラスを <code>ChatRoom.cs</code> に記述します。 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Chat;</span><br><span class="line"><span class="keyword">using</span> Grpc.Core;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Concurrent;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GrpcChatServer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChatRoom</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> ConcurrentDictionary&lt;<span class="keyword">string</span>, IServerStreamWriter&lt;Message&gt;&gt; users = <span class="keyword">new</span> ConcurrentDictionary&lt;<span class="keyword">string</span>, IServerStreamWriter&lt;Message&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">HasJoined</span>(<span class="params"><span class="keyword">string</span> name</span>)</span> =&gt; users.ContainsKey(name);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Join</span>(<span class="params"><span class="keyword">string</span> name, IServerStreamWriter&lt;Message&gt; response</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            users.TryAdd(name, response);</span><br><span class="line">            Console.WriteLine(<span class="string">$"[INFO] <span class="subst">&#123;name&#125;</span> has joined the rooom."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            users.TryRemove(name, <span class="keyword">out</span> <span class="keyword">var</span> _);</span><br><span class="line">            Console.WriteLine(<span class="string">$"[INFO] <span class="subst">&#123;name&#125;</span> has left the room."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">BroadcastMessageAsync</span>(<span class="params">Message message</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">await</span> BroadcastMessages(message);</span><br><span class="line">            Console.WriteLine(<span class="string">$"[INFO] <span class="subst">&#123;message.User&#125;</span> has broadcasted a message '<span class="subst">&#123;message.Text&#125;</span>'."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">BroadcastMessages</span>(<span class="params">Message message</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> user <span class="keyword">in</span> users.Where(x =&gt; x.Key != message.User))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> item = <span class="keyword">await</span> SendMessageToSubscriber(user, message);</span><br><span class="line">                <span class="keyword">if</span> (item != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Remove(item?.Key);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">async</span> Task&lt;Nullable&lt;KeyValuePair&lt;<span class="keyword">string</span>, IServerStreamWriter&lt;Message&gt;&gt;&gt;&gt; SendMessageToSubscriber(KeyValuePair&lt;<span class="keyword">string</span>, IServerStreamWriter&lt;Message&gt;&gt; user, Message message)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> user.Value.WriteAsync(message);</span><br><span class="line">                <span class="comment">// Console.WriteLine($"[INFO] broadcast message '&#123;message.Text&#125;' from '&#123;message.User&#125;'.");</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Console.WriteLine(ex);</span></span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上で定義した <code>ChatRoom</code> を利用する <code>ChatService</code> を <code>ChatService.cs</code> に記述します。このとき、 <code>ChatService</code> クラスは gRPC によって自動生成された <code>ChatRoomBase</code> クラス ( <code>.proto</code> ファイルの <code>Service</code> に指定した名前の後に <code>Base</code> を付与して自動生成されるクラス) を継承する形で実装します。こうすることで、 Chat サービスを実装する際の通信回りの実装を基底クラスに委譲して、アプリ実装者はアプリケーションのロジックに専念することができるようになります。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Grpc.Core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GrpcChatServer</span></span><br><span class="line">&#123;</span><br><span class="line">    public class ChatService : Chat.ChatRoom.ChatRoomBase</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ChatRoom _chatroomService;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;ChatService&gt; _logger;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ChatService</span>(<span class="params">ChatRoom chatRoomService, ILogger&lt;ChatService&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _chatroomService = chatRoomService;</span><br><span class="line">            _logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">join</span>(<span class="params">IAsyncStreamReader&lt;Message&gt; requestStream, IServerStreamWriter&lt;Message&gt; responseStream, ServerCallContext context</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">await</span> requestStream.MoveNext()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_chatroomService.HasJoined(requestStream.Current.User))</span><br><span class="line">                &#123;</span><br><span class="line">                    _chatroomService.Join(requestStream.Current.User, responseStream);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">await</span> _chatroomService.BroadcastMessageAsync(requestStream.Current);</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="keyword">await</span> requestStream.MoveNext());</span><br><span class="line"></span><br><span class="line">            _chatroomService.Remove(context.Peer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上で定義した <code>ChatRoom</code> および <code>ChatService</code> を <code>Startup.cs</code> にて登録することで Chat サーバは完成です。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Hosting;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Http;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GrpcChatServer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// This method gets called by the runtime. Use this method to add services to the container.</span></span><br><span class="line">        <span class="comment">// For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            services.AddGrpc();</span><br><span class="line">            services.AddSingleton&lt;ChatRoom&gt;(); <span class="comment">// ここで ChatRoom を登録</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">            &#123;</span><br><span class="line">                app.UseDeveloperExceptionPage();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            app.UseRouting();</span><br><span class="line"></span><br><span class="line">            app.UseEndpoints(endpoints =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                endpoints.MapGrpcService&lt;ChatService&gt;(); <span class="comment">// ここで ChatService を登録</span></span><br><span class="line"></span><br><span class="line">                endpoints.MapGet(<span class="string">"/"</span>, <span class="keyword">async</span> context =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このように、 ASP.NET Core を用いて gRPC サービスを実装する際には、データのシリアライズや通信回りの実装を自動生成されたコードに委譲し、アプリケーション固有のロジックの実装に専念することができるようになります。</p><h3 id="gRPC-で通信する-Chat-クライアントを-ASP-NET-Core-で実装する"><a href="#gRPC-で通信する-Chat-クライアントを-ASP-NET-Core-で実装する" class="headerlink" title="gRPC で通信する Chat クライアントを ASP.NET Core で実装する"></a>gRPC で通信する Chat クライアントを ASP.NET Core で実装する</h3><p>Visual Studio を立ち上げ、「新しいプロジェクトの作成」から「コンソールアプリ（.NET Core）」を選択し、テンプレートプロジェクト（プロジェクト名： <code>GrpcChatClient</code> ）を作成します。</p><p>まず最初に以下の三つのパッケージを <code>GrpcChatClient</code> にインストールします。</p><ul><li><code>Google.Protobuf (2.31.0)</code></li><li><code>Grpc.Net.Clien (2.31.0)</code></li><li><code>Grpc.Tools (2.31.0)</code></li></ul><p>つづけて、 <code>GrpcChatClient</code> プロジェクト内に <code>Protos</code> フォルダを作成し、<code>GrpcChatServer</code> と同じ <code>chat.proto</code> ファイルをコピーし、 <code>GrpcChatClient.csproj</code> に以下の <code>&lt;ItemGroup&gt;</code> を追加します。ここでも同様に<code>GrpcServices=&quot;Client&quot;</code> と記載することで、 <code>.proto</code> ファイルから gRPC クライアント用のコードが自動生成されることになります。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Protobuf</span> <span class="attr">Include</span>=<span class="string">"Protos\*.proto"</span> <span class="attr">GrpcServices</span>=<span class="string">"Client"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最後に、 <code>Program.cs</code> に Chat クライアントのコードを記述してクライアントの実装は終了です。クライアントの実装では、サーバの実装と同様に gRPC によって自動生成されたクライアント用コードを <code>using</code> することで用います。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Grpc.Net.Client;</span><br><span class="line"><span class="keyword">using</span> Chat; <span class="comment">// ここで gRPC によって自動生成されたコードを利用することを宣言</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GrpcChatClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"[INFO] Hello World! I am GrpcChatClient!"</span>);</span><br><span class="line">            Console.Write(<span class="string">"Input your user name: "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> userName = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>);</span><br><span class="line">            <span class="keyword">var</span> client = <span class="keyword">new</span> ChatRoom.ChatRoomClient(channel);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> chat = client.<span class="keyword">join</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                _ = Task.Run(<span class="keyword">async</span> () =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">await</span> chat.ResponseStream.MoveNext(cancellationToken: CancellationToken.None))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> response = chat.ResponseStream.Current;</span><br><span class="line">                        Console.WriteLine(<span class="string">$"[<span class="subst">&#123;response.User&#125;</span>]: <span class="subst">&#123;response.Text&#125;</span>"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">await</span> chat.RequestStream.WriteAsync(<span class="keyword">new</span> Message &#123; User = userName, Text = <span class="string">$"[INFO] <span class="subst">&#123;userName&#125;</span> has joined the room."</span> &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">string</span> line;</span><br><span class="line">                <span class="keyword">while</span> ((line = Console.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (line.ToLower() == <span class="string">"bye"</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">await</span> chat.RequestStream.WriteAsync(<span class="keyword">new</span> Message &#123; User = userName, Text = line &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">await</span> chat.RequestStream.CompleteAsync();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">"[INFO] Disconnecting..."</span>);</span><br><span class="line">            <span class="keyword">await</span> channel.ShutdownAsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ここまで終了したら、いよいよサーバとクライアントを通信させることができます。</p><p>複数コマンドプロンプトを立ち上げて、サーバとクライアントをそれぞれ実行し、通信することができるかを確かめてみましょう。</p><img src="/blog/web-apps/GrpcChatOnAspNetCore/2client1server.png" class=""><p>（画像右半分がサーバアプリの画面、画像左半部がクライアントアプリの画面）</p><h3 id="gRPC-で通信する-Chat-クライアントを-go-で実装する"><a href="#gRPC-で通信する-Chat-クライアントを-go-で実装する" class="headerlink" title="gRPC で通信する Chat クライアントを go で実装する"></a>gRPC で通信する Chat クライアントを go で実装する</h3><p>gRPC は、サービスのインタフェースが Protocol Buffer という、プログラミング言語とは独立した形で記述されることから、互いに異なるプログラミング言語を用いてサーバとクライアントを開発することが容易であるという特徴があります。</p><p>そこで、ここまでで開発した Chat サーバと通信する Chat クライアントを C# とは別の <a href="https://golang.org/" target="_blank" rel="noopener">Go</a> という言語で開発してみましょう。なお、今回はあくまで検証用のサンプルのご紹介であり、go 言語のサンプルアプリのサポートや以下の環境構築に関するサポートは弊社では行っておりませんことご了承ください。</p><p>Windows における Go/gRPC 開発環境の構築については下記サイトなどを参考に行ってください。</p><p>参考：<a href="https://golang.org/doc/install" target="_blank" rel="noopener">https://golang.org/doc/install</a><br>参考：<a href="https://grpc.io/blog/installation/" target="_blank" rel="noopener">https://grpc.io/blog/installation/</a></p><p>Go でのクライアント実装でも、コマンドで通信部分のソースコードを自動生成し、それを利用する形でクライアントを記述していくことには変わりありません。</p><p>Chat クライアントの Go 実装については下記リポジトリを参考にしてください。</p><p>Go クライアントリポジトリ：<a href="https://github.com/jpdsi/GrpcChatSample/tree/master/GrpcChatClientGo/chat" target="_blank" rel="noopener">https://github.com/jpdsi/GrpcChatSample/tree/master/GrpcChatClientGo/chat</a></p><h3 id="実際に通信させてみる"><a href="#実際に通信させてみる" class="headerlink" title="実際に通信させてみる"></a>実際に通信させてみる</h3><p>Go 実装のクライアントと C# 実装のクライアント、 C# 実装のサーバを立ち上げ実際に通信できることを確認してみます。</p><img src="/blog/web-apps/GrpcChatOnAspNetCore/3client1server.png" class=""><p>（画像右上がサーバアプリの画面、画像下半分が C# クライアントアプリの画面、画像左上が Go クライアントアプリの画面）</p><p>このように、 gRPC では異なる言語によるサーバ・クライアントの実装が容易に実現することができます。</p><p>今回作ったチャットアプリのコードは以下のリポジトリにあります。</p><p>リポジトリ：<a href="https://github.com/jpdsi/GrpcChatSample" target="_blank" rel="noopener">https://github.com/jpdsi/GrpcChatSample</a></p><h2 id="他のサンプルも見てみたい方へ"><a href="#他のサンプルも見てみたい方へ" class="headerlink" title="他のサンプルも見てみたい方へ"></a>他のサンプルも見てみたい方へ</h2><p>今回は gRPC を使った Chat サービスを ASP.NET Core を利用して実装してみました。<br>gRPC では他にも様々な通信をサポートしており、 ASP.NET Core による実装例も以下のリポジトリから確認することができます。</p><p>ASP.NET Core を利用した gRPC 開発を検討の際には、開発したいものに合わせたサンプルを参照すると、参考になるかと思います。</p><p>サンプルリポジトリ：<a href="https://github.com/grpc/grpc-dotnet/tree/master/examples" target="_blank" rel="noopener">https://github.com/grpc/grpc-dotnet/tree/master/examples</a></p><p>今回は以上です。<br>ASP.NET CoreでgRPCを簡単に実装できることがお分かりいただけましたでしょうか？<br>それでは、また次回！</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。&lt;br&gt;Developer Support Internet チーム にてインターンをしている尾崎耀一と申します！&lt;/p&gt;
&lt;p&gt;今回は ASP.NET Core を用いて、 gRPC で動く CLI （コマンドライン）でチャットができるアプリを作る方法を紹介し
      
    
    </summary>
    
    
    
      <category term="ASP.NET Core" scheme="https://jpdsi.github.io/blog/tags/ASP-NET-Core/"/>
    
      <category term="gRPC" scheme="https://jpdsi.github.io/blog/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>自社開発した Microsoft Edge (Chromium) の拡張機能を社内で自動展開する方法</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/how-to-deploy-edge-extensions/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/how-to-deploy-edge-extensions/</id>
    <published>2020-08-25T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:04.014Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。</p><p>今回は、自社開発などで Microsoft Store に登録されていない Microsoft Edge (Chromium) の拡張機能を、社内で自動展開する方法について紹介します。拡張機能のサンプルは <a href="https://docs.microsoft.com/ja-jp/microsoft-edge/extensions-chromium/getting-started/part1-simple-extension" target="_blank" rel="noopener">チュートリアル</a> からダウンロードできます。</p><span style="color: red;">自動展開 (強制インストール) を行うには、Microsoft Active Directory ドメインに参加している Windows デバイスである必要があります。ドメインに参加していない Windows デバイスについては、強制インストールは Microsoft Store で利用できる拡張機能に限定されます。</span><h2 id="拡張機能のパック-CRX-ファイルの作成-と-ID-の確認"><a href="#拡張機能のパック-CRX-ファイルの作成-と-ID-の確認" class="headerlink" title="拡張機能のパック (CRX ファイルの作成) と ID の確認"></a>拡張機能のパック (CRX ファイルの作成) と ID の確認</h2><p>まずは開発した (用意した) 拡張機能をパッケージ化する必要があります。パッケージ化と ID の確認は以下の手順で行います。</p><ol><li>edge://extensions を開いて [開発者モード] を有効にします。</li></ol><img src="/blog/internet-explorer-microsoft-edge/how-to-deploy-edge-extensions/developer-mode.png" class=""><ol start="2"><li>[拡張機能のパック] をクリックして、[拡張ルート ディレクトリ] に用意した拡張機能のルートを指定します。</li></ol><img src="/blog/internet-explorer-microsoft-edge/how-to-deploy-edge-extensions/pack-extension.png" class=""><img src="/blog/internet-explorer-microsoft-edge/how-to-deploy-edge-extensions/pack-extension-2.png" class=""><ol start="3"><li>[拡張機能のパック] ボタンをクリックすると、指定したパスの親フォルダーにパッケージ (CRX ファイル) が作成されます。</li></ol><p>※ 秘密鍵 (PEM ファイル) は今回使用しませんが、今後拡張機能をアップデートして再パッケージする際に必要になります</p><ol start="4"><li>作成された CRX ファイルを Microsoft Edge にドラッグ &amp; ドロップして [拡張機能の追加] をクリックします。</li></ol><img src="/blog/internet-explorer-microsoft-edge/how-to-deploy-edge-extensions/add-extension.png" class=""><ol start="5"><li>追加された拡張機能を確認し、ID とバージョン番号をメモしておきます。</li></ol><img src="/blog/internet-explorer-microsoft-edge/how-to-deploy-edge-extensions/confirm-extension-id.png" class=""><h2 id="CRX-ファイルの-Web-サーバーへの配置と更新マニフェストの作成"><a href="#CRX-ファイルの-Web-サーバーへの配置と更新マニフェストの作成" class="headerlink" title="CRX ファイルの Web サーバーへの配置と更新マニフェストの作成"></a>CRX ファイルの Web サーバーへの配置と更新マニフェストの作成</h2><p>作成した CRX ファイルを Web サーバーに配置し、ダウンロードできることを確認しておきます。<br>CRX ファイルは既定で許可された MIME タイプではないため、Web サーバーで設定が必要な場合があります。<br>例えば、IIS では、以下のように Web.config で MIME タイプの設定を行う必要があります。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">system.webServer</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">staticContent</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">mimeMap</span> <span class="attr">fileExtension</span>=<span class="string">".crx"</span> <span class="attr">mimeType</span>=<span class="string">"application/x-chrome-extension"</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">staticContent</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">system.webServer</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更新マニフェスト (XML ファイル) を作成し、同じく Web サーバーに配置します。<br>更新マニフェストは、以下のような内容のファイルを用意します。ID とバージョンは先ほどメモした値を使用し、codebase には CRX ファイルの URL を記載します。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gupdate</span> <span class="attr">xmlns</span>=<span class="string">'http://www.google.com/update2/response'</span> <span class="attr">protocol</span>=<span class="string">'2.0'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app</span> <span class="attr">appid</span>=<span class="string">'gcfmppplpjjdihbhljakgaihencjcngk'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">updatecheck</span> <span class="attr">codebase</span>= <span class="string">'https://edgewatcher.azurewebsites.net/nasa_picture_viewer.crx'</span> <span class="attr">version</span>=<span class="string">'0.0.0.1'</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">gupdate</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="グループ-ポリシーを構成する"><a href="#グループ-ポリシーを構成する" class="headerlink" title="グループ ポリシーを構成する"></a>グループ ポリシーを構成する</h2><p>拡張機能の自動展開のために <a href="https://docs.microsoft.com/ja-jp/DeployEdge/microsoft-edge-policies#extensioninstallforcelist" target="_blank" rel="noopener">サイレント インストールされる拡張機能を制御する</a> のグループ ポリシーを構成します。<br>値の部分には、拡張機能の ID と更新マニフェストの URL をセミ コロン (;) で連結した文字列を設定します。<br>ポリシーが正しくクライアントに適用されたかどうかは、edge://policy で確認できます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcfmppplpjjdihbhljakgaihencjcngk;https:&#x2F;&#x2F;edgewatcher.azurewebsites.net&#x2F;nasa_picture_viewer.xml</span><br></pre></td></tr></table></figure><p>以上で設定は完了です。正しく設定できていれば、Microsoft Edge 起動時に自動的に拡張機能がインストールされ、有効になります。</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。&lt;/p&gt;
&lt;p&gt;今回は、自社開発などで Microsoft Store に登録されていない Microsoft Edge (Chromium) の拡張機能を、社内で自動展開する方法について紹介します。拡張機能のサンプルは &lt;a href=&quot;https://doc
      
    
    </summary>
    
    
    
      <category term="Microsoft Edge" scheme="https://jpdsi.github.io/blog/tags/Microsoft-Edge/"/>
    
      <category term="Chromium" scheme="https://jpdsi.github.io/blog/tags/Chromium/"/>
    
      <category term="Extensions" scheme="https://jpdsi.github.io/blog/tags/Extensions/"/>
    
  </entry>
  
  <entry>
    <title>IE の調査に必要なダンプ ファイルの採取について</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/dump/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/dump/</id>
    <published>2020-06-22T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:03.535Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。</p><p>Internet Explorer は Web コンテンツ (html や CSS、JavaScript、画像、動画などなど) を表示 / 動作させるための、いわば「プラットフォーム」です。<br>Web コンテンツ自体の構成やその中で行われている処理が、プラットフォームであるInternet Explorer に影響を及ぼすことも多くあります。<br>また、Internet Explorer  を取り巻く環境に影響を受けることも多々あります。<br>例えば、アドオンやサードパーティ製のソフトウェアの影響を受けてしまうことも。</p><p>このような状況で Internet Explorer を使っていると、「Internet Explorer は動作を停止しました」や「XXXX は応答していません」という事象が発生することがあります。<br>そんなとき、原因究明の最初の一歩となる情報がダンプ ファイルです。</p><p>ダンプ ファイルは、採取していただく瞬間の状態を記録するものとなります。<br>写真と同じと考えていただけると分かりやすいと思います。<br>写真を撮るとき、シャッターチャンスを逃してしまい、撮りたいものが何も写っていないということがありますが、実はダンプ ファイルも同じことが言えます。<br>このため、ダンプ ファイルはタイミングを見計らって採取していただくことがとても重要となります。</p><p>お問い合わせいただいた際に、上述のような事象の場合はダンプ ファイルの取得をお願いすることがありますが、せっかく取得していただいたファイルに手がかりが何も残っていないということがよくあります。<br>このため今回はダンプ ファイルの採取方法についてご案内いたします。</p><p>以下のような手順でダンプ ファイルを採取していただき、お問い合わせの際にご提供いただけますと、事象の解決までスムーズに進められますので、ぜひご確認ください！</p><h2 id="ハングしているときには"><a href="#ハングしているときには" class="headerlink" title="ハングしているときには"></a>ハングしているときには</h2><p>Internet Explorer がハングしている (応答なし) ときは、以下のようなメッセージが表示されています。</p><p>　 <img src="/blog/internet-explorer-microsoft-edge/dump/IEHangBar.png" class=""></p><p>この場合は、渋滞中の高速道路と似ています。渋滞が発生している最中にその状況を確認しなければ、解消してからでは何が起こっていたのかは分かりません。<br>さらに、渋滞の列のどこで何が起こっているのかを確認するためには、複数の箇所を確認する必要があります。</p><p>このためハングしている場合は、ダンプファイルは上記の通知バーが表示されている間（事象が起こっている間）に、“間隔をあけて”、“複数回” ダンプファイルの採取を実行してください。<br>こうすることで、処理がループしているような箇所を可能な限り絞り込むための有効な情報となります。<br>通知バーが消えてしまいますと、ハング状態から回復し、正常な状態となってしまうため、重要な証拠写真を取り損ねてしまいます。<br>採取のタイミングには十分ご注意ください。</p><h2 id="クラッシュしているときには"><a href="#クラッシュしているときには" class="headerlink" title="クラッシュしているときには"></a>クラッシュしているときには</h2><p>Internet Explorer がクラッシュしている（異常終了）のときは、以下のようなメッセージが表示されています。</p><p>　<img src="/blog/internet-explorer-microsoft-edge/dump/IEcrashDialog.png" class=""></p><p>この場合は、交通事故でいうと “事故直後” と同様で、すでに事象が発生している状態となります。<br>事故によりどこが大きく破損しているか、被害者はいるのか、など事故につながる情報を収集することと似ています。<br>すでに起こった事象の情報が取得できればよいため、ダンプファイルの採取（証拠写真の撮影）は “1 回” で大丈夫です。</p><p>ここまで注意点をまとめてきましたが、何より一番大事なことは、<strong>事象を再現させること</strong> になります。<br>なかなか再現しない場合は、まずは再現率を上げる、もしくは再現条件の確立を目指しましょう。<br>その過程で、ダンプファイルを取得することなく解決する場合も多々あります。</p><p>ここまでできましたら、以下の操作で証拠写真（ダンプファイル）を撮りましょう。</p><h2 id="事象が再現したら"><a href="#事象が再現したら" class="headerlink" title="事象が再現したら"></a>事象が再現したら</h2><p>事象が再現しましたら、以下の手順でダンプファイルを採取します。<br>ハングの場合もクラッシュの場合も採取方法は同じです。<br>ただし、ハングの場合は後述にもありますように、複数回操作をしていただく必要がありますのでご注意ください！</p><p>1．タスクバーを右クリックして、タスク マネージャーを起動します。 </p> <img src="/blog/internet-explorer-microsoft-edge/dump/Step1.png" class=""><ol start="2"><li><p>[詳細] タブを開きます。</p><img src="/blog/internet-explorer-microsoft-edge/dump/Step2.png" class=""></li><li><p>[名前] 列をクリックしてソートし、”iexplore.exe” を探します。<br>※ “iexplore.exe” のプロセスは複数存在しますので、すべてのプロセスに対して取得してください。</p></li><li><p>3 で探したすべての iexplore.exe に対して 1 つずつ、右クリック メニューから [ダンプ ファイルの作成] を選択します。</p><img src="/blog/internet-explorer-microsoft-edge/dump/Step4.png" class=""></li><li><p>ダンプ ファイルの作成に成功すると、ダイアログで保存場所が表示されるため、確認しておきます。<br>※ 既定では、環境変数 TEMP フォルダー以下に作成され、iexplore.DMP、iexplore (2).DMP のようなファイル名となります。</p><img src="/blog/internet-explorer-microsoft-edge/dump/Step5.png" class=""></li></ol><p>※    クラッシュの場合の手順はここまでです。</p><h3 id="★ハング事象の場合"><a href="#★ハング事象の場合" class="headerlink" title="★ハング事象の場合"></a>★ハング事象の場合</h3><p>上述の手順3～5 を間隔を空けながら 2、3 回繰り返します。<br>※ 例えば、事象が 2 ～ 3 分続く場合は、30 秒ごとに採取するなど、事象発生時間に合わせて採取します。<br>※ 上記のスクリーンショットの例では、３つの iexplore.exe が存在したため、同じ操作を2回ずつ実施すると、iexplore.DMP、iexplore (2).DMP、iexplore (3).DMP、… と6つのファイルができます。</p><h3 id="★ハング事象の発生時間が短いなら"><a href="#★ハング事象の発生時間が短いなら" class="headerlink" title="★ハング事象の発生時間が短いなら"></a>★ハング事象の発生時間が短いなら</h3><p>ハングの場合は事象発生中に複数回実施する必要があるため、事象発生時間が短い場合は上述の手順では採取が難しいことがあります。<br>その場合、ProcDump というツールを利用すると、上述の手順 4 でご紹介しているIE のすべてのプロセスのダンプ ファイルを一気に取得できます。<br>タスクマネージャーから手動で実行する手間がないので、ハング事象が 30 秒などと短い場合にはこちらの方法で取得することをお勧めしております。</p><p>1．ProcDump ツールは以下のサイトから実行ファイルをダウンロードできます。</p><p>　<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procdump" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/sysinternals/downloads/procdump</a></p><p>2．ProcDump の実行ファイルと以下の VBScript を事前に端末に配置します。<br>　※　いつでも実行できますので、IE を起動して、コマンドを実行したときに、ダンプ ファイルが取得できるかを事前にご確認ください。</p><p>なお、以下のサンプルスクリプトでは、C:\dump フォルダーに procdump.exe を格納し、コマンド実行すると、c:\dump フォルダーに、IE のダンプを出力するという例になります。<br>※    フォルダーは任意の場所を指定してください。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set objWMIService &#x3D; GetObject(&quot;winmgmts:\\.\root\cimv2&quot;) </span><br><span class="line">Set colItems &#x3D; objWMIService.ExecQuery(&quot;Select * From Win32_Process&quot;) </span><br><span class="line"></span><br><span class="line">Set WshShell &#x3D; WScript.CreateObject(&quot;WScript.Shell&quot;)</span><br><span class="line"></span><br><span class="line">For Each objItem in colItems </span><br><span class="line">    If InStr(LCase(objItem.CommandLine), &quot;iexplore.exe&quot;) Then </span><br><span class="line">        WshShell.Exec(&quot;c:\dump\procdump.exe -accepteula -ma &quot;&amp;objItem.ProcessID&amp;&quot; c:\dump\ie&quot;&amp;objItem.ProcessID&amp;&quot;.dmp&quot;)</span><br><span class="line">    End If </span><br><span class="line">Next</span><br></pre></td></tr></table></figure><p>3．IE を起動して、ハングの事象が発生しましたら、発生中に間隔をあけて手順 2 の VBScript を数回実行します。</p><p>原因究明の最初の一歩となるダンプファイルが取得できましたら、発生する現象について詳細なご説明を添えて、私共、サポートチームへお問い合せください！</p><p>今回は以上です。 それでは、また次回！</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。 もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。&lt;/p&gt;
&lt;p&gt;Internet Explorer は Web コンテンツ (html や CSS、JavaScript、画像、動画などなど) を表示 / 動作させるための、いわば「プラットフォーム」です。&lt;br&gt;Web コンテンツ自体の構成やその中で行われてい
      
    
    </summary>
    
    
    
      <category term="Internet Explorer" scheme="https://jpdsi.github.io/blog/tags/Internet-Explorer/"/>
    
      <category term="Dump" scheme="https://jpdsi.github.io/blog/tags/Dump/"/>
    
  </entry>
  
  <entry>
    <title>まだデフォルトIE？ 新しい Microsoft Edge を使いませんか？</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/how-about-using-new-edge/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/how-about-using-new-edge/</id>
    <published>2020-06-02T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:03.914Z</updated>
    
    <content type="html"><![CDATA[<p>今回は、<strong>Internet Explorer は可能な限り利用せずに Microsoft Edge などモダン ブラウザーを利用しましょう</strong>という話です。</p><p>「<a href="https://social.msdn.microsoft.com/Forums/ja-JP/47290e24-fc66-4d3e-a2de-429643758d40/internet-explorer-12398201702446012395123881235612390?forum=edgeiesupportteamja" target="_blank" rel="noopener">Internet Explorer の今後について</a>」という記事を公開してから１年ちょっと経ちました。</p><blockquote><p>Windows 10 においては、Microsoft Edge と Internet Explorer というふたつのブラウザーが搭載されていますが、弊社としましては、<span style="background: linear-gradient(transparent 80%, #ffcc99 80%)">Internet Explorer との後方互換性が必要な業務 Web システムには Internet Explorer を利用いただき、Internet Explorer でなければならない場合以外は Microsoft Edgeをご利用いただくことを提案</span>してきました。</p></blockquote><p>2015 年に Microsoft Edge をリリースして以降、<strong>Internet Explorer は従来の Web アプリケーションとの後方互換性のために残しているブラウザー</strong>という位置づけです。業務のための Web アプリケーションが、古いブラウザーである Internet Explorer 固有の機能 (ActiveX コントロール、ブラウザー ヘルパー オブジェクト、VBScript などの古い技術) に依存していて、モダン ブラウザーでは扱えないという悩みは多くの企業が抱えています。古い Web アプリケーションを見直して、モダン ブラウザーで表示できるようにするまでの間はどうしても Internet Explorer が不可欠ですので、Windows 10 でも Internet Explorer が残されています。</p><p>Internet Explorer と Microsoft Edge の位置づけは上述のとおりですが、私たちサポート チームが対応するお問い合せの中で「Internet Explorer で表示に時間がかかります。Chrome では問題ありません。」という内容をよくみかけます。こういうお問い合せでは『Internet Explorer でなければならない理由は何か？』が焦点になります。</p><p>以下は 5 年前の記事ですが、この当時でも、Microsoft Edge や Google Chrome と比較した場合 Internet Explorer は 5 割程度のスクリプト性能でした。</p><p>Delivering fast JavaScript performance in Microsoft Edge<br><a href="https://blogs.windows.com/msedgedev/2015/05/20/delivering-fast-javascript-performance-in-microsoft-edge/" target="_blank" rel="noopener">https://blogs.windows.com/msedgedev/2015/05/20/delivering-fast-javascript-performance-in-microsoft-edge/</a></p><p>この 5 年の間もモダン ブラウザーは積極的な開発が続けられていますが、レガシー ブラウザーである Internet Explorer は最新の Web 標準のサポートやパフォーマンスの向上への注力はしていませんので、パフォーマンスの差はさらに広がっています。どのような Web ページの表示が遅いのかを伺ってみると、ほとんどの場合は、最新の Web 標準の技術を取り入れたリッチなコンテンツでしたので、上記のことを考えれば、Internet Explorer としてのパフォーマンス性能の限界と言えます。こういった問題を回避するためにも <a href="https://blogs.windows.com/japan/2020/01/16/upgrading-new-microsoft-edge-79-chromium/" target="_blank" rel="noopener">Chromium ベースの新しい Microsoft Edge</a> の利用を強くおすすめします。</p><p>新しい Microsoft Edge では『IE モード』という機能を搭載しています。一言でいうと『Microsoft Edge の画面の中で Internet Explorer が動く』というものです。詳細は <a href="https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode" target="_blank" rel="noopener">公式ドキュメント</a> や <a href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/IEMode/">サポート チームのブログ記事</a> をご覧いただければと思いますが、適切に制御することで、ユーザーが Internet Explorer と Microsoft Edge を意識的に使い分ける操作をせずに、Internet Explorer を必要とする古い技術で作られた Web アプリケーションを、Microsoft Edge の中でシームレスに閲覧できるようになります。IE モードの登場により、『Internet Explorer を単独で動かすのではなく、IE/Edge どちらにも対応したブラウザ環境を提供』→『今後は IE ではなく、Microsoft Edge で動作する Web アプリケーションを用意する』という段階的な移行を進めやすくなりました。ぜひ活用していただければと思います。</p><p>最後に、『最新の Web 標準の技術を取り入れたリッチなコンテンツ』の例を挙げます。弊社製品のひとつである Power BI ですが、以下の公式ドキュメントでサポートされるブラウザーについて記述があります。</p><p>Power BI のサポートされているブラウザー<br><a href="https://docs.microsoft.com/ja-jp/power-bi/power-bi-browsers" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/power-bi/power-bi-browsers</a></p><blockquote><p>Power BI はこれらのサポートされているすべてのブラウザーで動作するように設計されていますが、<span style="background: linear-gradient(transparent 80%, #ffcc99 80%)">選択したブラウザーによってパフォーマンスは異なります。 特に Internet Explorer を使用している場合は、パフォーマンスが低下する可能性があります。 パフォーマンスを向上させるには、Internet Explorer から Microsoft Edge などの最新のブラウザーに切り替えることを強くお勧めします。</span> Edge Chromium を使用すると、Microsoft Edge のパフォーマンスは引き続き向上することが期待されています。 それでも許容できないパフォーマンスが発生する場合は、サポートされている他の最新のブラウザーをテストして、Power BI ソリューションでより良い結果が得られるかどうかを確認します。</p></blockquote><p>私たちブラウザー サポート チームがいつも言いたいことをしっかりと書いてくれています。イマドキのことをやるなら最新のブラウザーを使うべきです。もちろん組織ごとに事情はあるでしょう。でも、古いブラウザーを使い続けると、多くのユーザーがパフォーマンスに不満を感じたり、組織としての生産性にも影響を及ぼしかねません。イマドキのコンテンツに見合った最新のブラウザーを使うことでユーザーは快適に作業できるようになります。IT 管理者のみなさん、まずはモダン化の一歩を踏み出してみませんか。</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今回は、&lt;strong&gt;Internet Explorer は可能な限り利用せずに Microsoft Edge などモダン ブラウザーを利用しましょう&lt;/strong&gt;という話です。&lt;/p&gt;
&lt;p&gt;「&lt;a href=&quot;https://social.msdn.microso
      
    
    </summary>
    
    
    
      <category term="Microsoft Edge" scheme="https://jpdsi.github.io/blog/tags/Microsoft-Edge/"/>
    
      <category term="IE モード" scheme="https://jpdsi.github.io/blog/tags/IE-%E3%83%A2%E3%83%BC%E3%83%89/"/>
    
  </entry>
  
  <entry>
    <title>New Microsoft Edge でレッツ サーフィン</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/</id>
    <published>2020-06-01T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:04.500Z</updated>
    
    <content type="html"><![CDATA[<p>皆様、いい波乗ってますか？<br>2020 年 5 月、New Microsoft Edge 安定版 83 がリリースされました。<br>いくつかの機能追加や修正が加えられていますが、今回私たち Microsoft ブラウザサポートチームから紹介するのはこれ！</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/01.jpg" class=""><p>これまで隠し機能として搭載されていたサーフ ゲームが誰でも遊べるようになりました。</p><p>  Introducing the new surf game in Microsoft Edge<br>  <a href="https://blogs.windows.com/msedgedev/2020/05/26/surf-game-edge-stable/" target="_blank" rel="noopener">https://blogs.windows.com/msedgedev/2020/05/26/surf-game-edge-stable/</a></p><p>このゲームへのアクセス方法は簡単！New Microsoft Edge のアドレスバーに “edge://surf” と入力するだけです。<br>もしまだ New Microsoft Edge をインストールされていなければ、こちらの<a href="https://www.microsoft.com/ja-jp/edge" target="_blank" rel="noopener">ダウンロードサイト</a>からどうぞ！</p><p>当然、我々サポートチームも New Microsoft Edge の機能を網羅すべくがっつりやり込みました。<br>その勢いに任せて、今回はサーフ ゲームのレッツ サーフィン モードの攻略を、以下の構成でお話ししていきます。</p><ol><li>レッツ サーフィン</li><li>クラーケンに始まりクラーケンに終わる</li><li>ゲームバランスが神ってる</li><li>障害物基礎</li><li>最後に</li></ol><h1 id="1-レッツ-サーフィン"><a href="#1-レッツ-サーフィン" class="headerlink" title="1. レッツ サーフィン"></a>1. レッツ サーフィン</h1><p>まずは遊び方を確認しましょう。画面右上のハンバーガーメニューから「プレイ方法」をクリック。<br>“ゲーム モード” が “レッツ サーフィン” であることを確認しておきましょう。他にもモードがありますがそれはまた別の機会に。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/02.jpg" class=""><p>なるほど、レッツ サーフィンは障害物やクラーケンを避けながら、とにかくゲームが終わらないように続ければよいゲームのようです。<br>ゲームオーバーの条件についてここには書かれていないですが、ライフであるハートが 0 になるとゲームオーバーです。<br>ライフの最大は 2 で、ハートを取ることで回復します。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/03.jpg" class=""><p>それにしても “障害物” と”クラーケン” ってなんでしょう。先ほどのハンバーガーメニューから、高視認性モードをオンにして確認してみましょう。<br>画面の黒い四角で囲われているオブジェクトが障害物で、同じく黒い四角で囲われている紫の足がクラーケンです。<br>赤い点線で表示されているオブジェクトは、ライフは削られないもののスピードが遅くなったり進行方向が変更されたりするオブジェクトです。<br>緑はライフの回復や加速パワーアップなどポジティブな効果があります。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/04.jpg" class=""><p>細かい説明を書いていくと超大作な記事になってしまうので概要はこの辺にして、攻略に入って行きましょう。</p><h1 id="2-クラーケンに始まりクラーケンに終わる"><a href="#2-クラーケンに始まりクラーケンに終わる" class="headerlink" title="2. クラーケンに始まりクラーケンに終わる"></a>2. クラーケンに始まりクラーケンに終わる</h1><p>このゲームはライフが 3 つあります。<br>障害物にあたると 1 つ減ります。逆に考えると 3 回もあたることができて、その間にハートを取れば回復可能です。余裕です。<br>一方クラーケンはライフが 3 つあっても、触れてしまえば即ゲームオーバーです。無慈悲です。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/05.jpg" class=""><p>そのため、クラーケン対策を行うことが、ハイスコアを伸ばす最優先事項になります。※あくまで個人の見解です<br>主な対策方法は、以下の 4 つです。</p><p>A. クラーケンの足に近寄らない<br>B. 迫りくるクラーケンを障害物にひっかける<br>C. 加速パワーアップで振り切る<br>D. 犬シールド  </p><p>それぞれ見ていきましょう。</p><h2 id="A-クラーケンの足に近寄らない"><a href="#A-クラーケンの足に近寄らない" class="headerlink" title="A. クラーケンの足に近寄らない"></a><u>A. クラーケンの足に近寄らない</u></h2><p>一番重要じゃないかもしれません。<br>というのもこの足に近寄らなくても他の条件でクラーケンは発生している気がするからです。<br>とはいえ、君子危うきに近寄らず。明らかに怪しいもの近づくのはやめておきましょう。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/06.jpg" class=""><h2 id="B-迫りくるクラーケンを障害物にひっかける"><a href="#B-迫りくるクラーケンを障害物にひっかける" class="headerlink" title="B. 迫りくるクラーケンを障害物にひっかける"></a><u>B. 迫りくるクラーケンを障害物にひっかける</u></h2><p>基本です。基本にして最後の手段です。クラーケンも障害物にひっかかるので、上手く誘導しましょう。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/07.jpg" class=""><h2 id="C-加速パワーアップで振り切る"><a href="#C-加速パワーアップで振り切る" class="headerlink" title="C. 加速パワーアップで振り切る"></a><u>C. 加速パワーアップで振り切る</u></h2><p>加速パワーアップを利用することで一時的にクラーケンより早くサーフできます。<br>F キーで使用できますが、実は方向キーの下を 2 回押すことでも使用可能です。<br>ただ賢明な皆様はお気づきでしょう。スピードの出しすぎはリスクを伴います。<br>できる限り障害物にひっかけてしのぎましょう。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/08.jpg" class=""><h2 id="D-犬シールド"><a href="#D-犬シールド" class="headerlink" title="D. 犬シールド"></a><u>D. 犬シールド</u></h2><p>犬かわいい、犬最強。<br>シールドが無くなる前に、新しい犬シールドを取得する犬シールドループを安定できるようになると、あなたはもう上級者です。<br>見かけたら最優先で助けに行きましょう。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/09.jpg" class=""><p>ライフがシールドで覆われ、クラーケンや他のサーファーのアタックを三回まで防げます。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/10.jpg" class=""><p>ただし犬シールドにも弱点はあり、障害物にあたってしまうと一発で剥がれます。<br>障害物からのクラーケンの即ゲームオーバーコンボは、幾度となく我々サポートチームを絶望に叩き落してきました。</p><h1 id="3-ゲームバランスが神ってる"><a href="#3-ゲームバランスが神ってる" class="headerlink" title="3. ゲームバランスが神ってる"></a>3. ゲームバランスが神ってる</h1><p>前項にて、クラーケン対策が最重要項目だとお伝えしてきました。 <strong>本当にそうでしょうか？</strong><br>最強名高い犬シールドの弱点は、障害物であることがわかりました。加速パワーアップの弱点も、障害物を避けづらくなる点にあります。<br>そしてクラーケンも障害物にひっかかって勝てません…我々は驚愕しました。 <strong>いつのまにか障害物が最強になってる！</strong></p><h2 id="障害物-gt-パワーアップアイテム-gt-クラーケン"><a href="#障害物-gt-パワーアップアイテム-gt-クラーケン" class="headerlink" title="障害物 &gt; パワーアップアイテム &gt; クラーケン"></a>障害物 &gt; パワーアップアイテム &gt; クラーケン</h2><p>方向キーの上を押せばその場で止まることができるので、止まりながら進めば障害物にあたる要素はありません。<br>しかししかしクラーケンの存在がそれをさせないため、 <strong>いかに上手く障害物を避けられるかという基本的なことが、</strong><br>ハイスコアに最も重要な要素であることに気づかされます。<br>この事実に気づいたとき、「あれこのゲーム、ひょっとしてレベルデザイナーついてるんじゃないか？」と震えました。</p><h1 id="4-障害物基礎"><a href="#4-障害物基礎" class="headerlink" title="4. 障害物基礎"></a>4. 障害物基礎</h1><p>ここにきて最強の座を得た障害物ですが、ある程度の規則をもって配置されているように見えます。<br>次のスクリーンショットは、障害物配置の一例です。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/11.jpg" class=""><p>パワーアップアイテムも合わせて配置されており、この規則性を把握しておくことは非常に重要です。<br>実はここにも落とし穴があり、規則的に配置される障害物に加えて、ランダムに配置される障害物で構成されているようです。<br>ちょっと油断していると、</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/12.jpg" class=""><p>とか</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/13.jpg" class=""><p>とか、想定外の配置に心を揺さぶられてしまうので、油断は禁物です。</p><h1 id="5-最後に"><a href="#5-最後に" class="headerlink" title="5. 最後に"></a>5. 最後に</h1><p>これまでに述べた攻略方法を駆使した結果、2020/5/31 時点でサポートチームの最高得点は <strong>103523</strong> メートルです。</p><img src="/blog/internet-explorer-microsoft-edge/LetsSurfing-on-New-Edge/14.jpg" class=""><p>この記録を達成した際、たまたまそのチームメンバーが Microsoft Teams で画面共有しながら実況プレイしておりました。<br>100000 メートルを超えたあたりで、明らかに集中力が切れていたので周りから <strong>「まじめにやれ」、「集中しろ」</strong> という言葉を浴びせられていました。<br>その時点で、チーム内での最高記録を大幅に更新していたのにも関わらずです。<br>私も言いました。何事にも妥協せず本気で取り組む、それが私たちブラウザサポートチームなのです。<br>余談ですが、本記録達成後、スクリーンショットを添えて開発チームに賛辞のメールを送付したことは、言うまでもありません。  </p><p>皆様もネットサーフィンの合間にレッツ サーフィン！<br>今後ともよろしくお願いいたします。</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;皆様、いい波乗ってますか？&lt;br&gt;2020 年 5 月、New Microsoft Edge 安定版 83 がリリースされました。&lt;br&gt;いくつかの機能追加や修正が加えられていますが、今回私たち Microsoft ブラウザサポートチームから紹介するのはこれ！&lt;/p&gt;
&lt;i
      
    
    </summary>
    
    
    
      <category term="Microsoft Edge" scheme="https://jpdsi.github.io/blog/tags/Microsoft-Edge/"/>
    
      <category term="Chromium" scheme="https://jpdsi.github.io/blog/tags/Chromium/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark による New Microsoft Edge のトレース取得方法</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/New-Edge-Wireshark/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/New-Edge-Wireshark/</id>
    <published>2020-05-31T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:04.624Z</updated>
    
    <content type="html"><![CDATA[<p><font color="red">2020/8/7 更新 : ブラウザーのキャッシュが利用されてキャプチャーに記録されないことを避けるために、InPrivate ブラウズをご利用いただく方法をご案内していますが、InPrivate ブラウズをご利用いただけない場合には、ログ取得前にブラウザーのキャッシュをすべて消去してください。</font></p><p>こんにちは。Developer Support Internet チームです！</p><p>今回は、Chromium ベースの New Microsoft Edge で動作する Web アプリケーションにて、ネットワークに関連する問題が起こった際に、もしかしたら活用できるかもしれない Wireshark を用いたネットワークトレース取得方法の Tips をご紹介いたします。</p><p>今回は Wireshark を利用して New Microsoft Edge で動作するクライアントアプリ側にてトレースを取得します。<br>なお、本方法では HTTPS の通信をキャプチャすることも可能ですが、TLS のバージョンや暗号化の種類等によっては正常に復号できない可能性もあり、全ての HTTPS 通信を分析できるものではありません。</p><p>また、この方法については、Chromium ベースではない旧 Microsoft Edge や Internet Explorer では適用できませんのでご注意ください。<br>また弊社サポート製品ではございませんが、Google Chrome で動作するクライアントアプリのネットワークトレース取得にも現時点では適用可能な方法と存じます。</p><hr><h2 id="0-前提"><a href="#0-前提" class="headerlink" title="0. 前提"></a>0. 前提</h2><ul><li><p>再現手順が確立されており、Chromium ベースの New Microsoft Edge にてネットワークに関する事象が再現可能</p><p>新しい Microsoft Edge ブラウザーをダウンロード | Microsoft<br><a href="https://www.microsoft.com/ja-jp/edge?form=MA13DE&amp;OCID=MA13DE" target="_blank" rel="noopener">https://www.microsoft.com/ja-jp/edge?form=MA13DE&amp;OCID=MA13DE</a></p></li><li><p>Wireshark がダウンロード済み</p><p>Download Wireshark<br><a href="https://www.wireshark.org/download.html" target="_blank" rel="noopener">https://www.wireshark.org/download.html</a></p></li></ul><hr><h2 id="1-事前準備"><a href="#1-事前準備" class="headerlink" title="1. 事前準備"></a>1. 事前準備</h2><ol><li><p>この Blog の記事の手順や再現するアプリの URL 等をノート帳 (Notepad) で開けるテキストファイル (.txt) などにコピーし開いておきます。</p></li><li><p>New Microsoft Edge や Google Chrome を含めて、全てのブラウザを閉じます。</p></li><li><p>ブラウザ以外のアプリも上記の 0 の手順のテキストファイル以外はすべて閉じます。</p></li><li><p>エクスプローラーにて、キーを保存する任意のフォルダ (C:\tmp) 等を作成しておきます。</p></li><li><p>コマンドプロンプトを開き、以下のコマンドで上記で作成した任意のフォルダ (ここでは C:\tmp と仮定) に空の新規ファイルを作成または既に存在する場合は同ファイルを空に上書きします。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; C:\tmp\ssl.txt</span><br></pre></td></tr></table></figure><br /><br /><hr><h2 id="2-ユーザー環境変数の設定"><a href="#2-ユーザー環境変数の設定" class="headerlink" title="2. ユーザー環境変数の設定"></a>2. ユーザー環境変数の設定</h2><p>ツールバーの検索等から “環境変数を編集” を開き、ユーザー環境変数の “新規” ボタンを<br>クリックし、”ユーザー変数の編集” にて、以下のように、ユーザー変数の環境変数を設定します。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">変数名 : SSLKEYLOGFILE</span><br><span class="line">変数値 : C:\tmp\ssl.txt</span><br></pre></td></tr></table></figure><br /><br /><img src="/blog/internet-explorer-microsoft-edge/New-Edge-Wireshark/sslkeylogfile.png" class=""><br /><br /><hr><h2 id="3-Wireshark-の準備"><a href="#3-Wireshark-の準備" class="headerlink" title="3. Wireshark の準備"></a>3. Wireshark の準備</h2><ol><li><p>Wireshark を開きます。</p></li><li><p>キャプチャーしたいインターフェース (イーサネット や wifi、vEthernet など) を選択します。</p></li><li><p>左上の赤い四角ボタンを押し、一度、停止しておきます。</p></li></ol><img src="/blog/internet-explorer-microsoft-edge/New-Edge-Wireshark/stop.png" class=""><br /><br /><hr><h2 id="4-New-Microsoft-Edge-による再現とキャプチャ"><a href="#4-New-Microsoft-Edge-による再現とキャプチャ" class="headerlink" title="4. New Microsoft Edge による再現とキャプチャ"></a>4. New Microsoft Edge による再現とキャプチャ</h2><p>4-1. New Microsoft Edge を InPrivate ウィンドウで開く。<br>(タスクバー等の Edge アイコンを右クリックで “新しい InPrivate ウィンドウ” で開けます)<br>※ InPrivate ブラウズをご利用いただけない場合には、ログ取得前にブラウザーのキャッシュをすべて消去してください。手順は後述の補足をご覧ください。</p><p>4-2. Wireshark にて、左上の青いシャークの形をしたボタンを押してキャプチャを開始する。<br>(保存に関するダイアログが出た場合、”保存せずに続ける” を押しキャプチャを開始する)</p><img src="/blog/internet-explorer-microsoft-edge/New-Edge-Wireshark/start.png" class=""><br /><p>4-3. New Microsoft Edge にて該当のサイトを開き、素早く事象の再現を行う。</p><p>4-4. 再現後、すぐに Wireshark に戻り、左上の赤い四角のボタンを再度押し、停止する。</p><hr><h2 id="5-復号"><a href="#5-復号" class="headerlink" title="5. 復号"></a>5. 復号</h2><p>5-1. Wireshark 上部の [編集] タブを押し、[設定] ボタンを押す。</p><p>5-2. 左側の [Protocols] 内の [TLS] を選択する。</p><p>5-3. [(Pre)-Master-Secret log filename] の [Browse] ボタンを選択し、C:\tmp\ssl.txt を選択する。</p><br /><img src="/blog/internet-explorer-microsoft-edge/New-Edge-Wireshark/premaster.png" class=""><br /><br /><p>5-4. [OK] ボタンを押し、復号し、キャプチャした内容を確認します。<br>(これを行うことで、全てではないものの、HTTPS の通信が復号されたキャプチャを見ることが可能となります)</p><p>イメージ : </p><img src="/blog/internet-explorer-microsoft-edge/New-Edge-Wireshark/wireshark.png" class=""><br /><br /><p>5-5. 必要に応じて、Wireshark 上部の [ファイル] タブを押し、[保存] ボタンから .pcapng 形式で保存します。</p><p>5-6. もし私共サポートから本 Blog による情報採取をご依頼された場合は、.pcapng ファイルと C:\tmp\ssl.txt の 2 つ両方とも提供します。</p><p>※ なお、Wireshark 自体のツールに関するトラブルシューティングや操作方法等のご質問は 3 rd party 製品となる為、Microsoft のサポートでは承ることができませんのでご了承ください。</p><hr><h2 id="6-後片付け"><a href="#6-後片付け" class="headerlink" title="6. 後片付け"></a>6. 後片付け</h2><p>2 で追加した環境変数 SSLKEYLOGFILE を削除します。</p><hr><h2 id="補足-ブラウザーのキャッシュ消去について"><a href="#補足-ブラウザーのキャッシュ消去について" class="headerlink" title="補足 : ブラウザーのキャッシュ消去について"></a>補足 : ブラウザーのキャッシュ消去について</h2><ol><li><p>New Microsoft Edge にて edge://settings/clearBrowserData を開きます。</p></li><li><p>以下のように設定し、[今すぐクリア] ボタンをクリックします。</p></li></ol><img src="/blog/internet-explorer-microsoft-edge/New-Edge-Wireshark/clearcache.png" class=""><hr><h2 id="補足-netsh-でのトレース取得方法"><a href="#補足-netsh-でのトレース取得方法" class="headerlink" title="補足 : netsh でのトレース取得方法"></a>補足 : netsh でのトレース取得方法</h2><p>New Microsoft Edge の SSLKEYLOGFILE を用いたネットワークトレースの復号について、ネットワークトレースを取得するツール自体は Wireshark ではなく、netsh でも取得は可能です。</p><p>私共サポートから  netsh を用いた New Microsoft Edge のトレース取得をご案内することもございますため、以下、簡単にその方法についても記載いたします。</p><ol><li><p>上部の “1. 事前準備” を行います。</p></li><li><p>“2. ユーザー環境変数の設定” を行います。</p></li><li><p>“Wireshark の準備”　は実施せずにスキップ</p></li><li><p>“4. New Microsoft Edge による再現とキャプチャ” は以下の手順で実施します (上部の 5 はスキップします)</p></li></ol><p>4-1. New Microsoft Edge を InPrivate ウィンドウで開く。<br>(タスクバー等の Edge アイコンを右クリックで “新しい InPrivate ウィンドウ” で開けます)<br>※ InPrivate ブラウズをご利用いただけない場合には、ログ取得前にブラウザーのキャッシュをすべて消去してください。手順は上述の補足をご覧ください。</p><p>4-2. 管理者権限でコマンド プロンプトを開き、次のコマンドを実行し、キャプチャを開始します。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　netsh trace start capture&#x3D;yes maxSize&#x3D;2000MB</span><br></pre></td></tr></table></figure><p>4-3. New Microsoft Edge にて該当のサイトを開き、素早く事象の再現を行う。</p><p>4-4. 次のコマンドを実行して、キャプチャを停止します (しばらく時間がかかります)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　netsh trace stop</span><br></pre></td></tr></table></figure><p>4-5. もし私共サポートから本 Blog による New Microsoft Edge の netsh の情報採取をご依頼された場合は、トレースの .etl ファイルと .cab ファイルと C:\tmp\ssl.txt の 3 つ両方とも提供します。</p><p>(参考) 以下の etl2pcapng を利用すると、.etl を Wireshark で開ける .pcapng　形式に変換できます。</p><p>etl2pcapng<br><a href="https://github.com/microsoft/etl2pcapng" target="_blank" rel="noopener">https://github.com/microsoft/etl2pcapng</a></p><p>コマンド例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etl2pcapng in.etl out.pcapng</span><br></pre></td></tr></table></figure><hr><hr><h2 id="補足２-pktmon-でのトレース取得方法"><a href="#補足２-pktmon-でのトレース取得方法" class="headerlink" title="補足２ : pktmon でのトレース取得方法"></a>補足２ : pktmon でのトレース取得方法</h2><p>Windows 10 の 1809 から pktmon が搭載されており、上述の netsh と同様にネットワークトレースを取ることができます。</p><ol><li><p>上部の “1. 事前準備” を行います。</p></li><li><p>“2. ユーザー環境変数の設定” を行います。</p></li><li><p>“Wireshark の準備”　は実施せずにスキップ</p></li><li><p>“4. New Microsoft Edge による再現とキャプチャ” は以下の手順で実施します (上部の 5 はスキップします)</p></li></ol><p>4-1. New Microsoft Edge を InPrivate ウィンドウで開く。<br>(タスクバー等の Edge アイコンを右クリックで “新しい InPrivate ウィンドウ” で開けます)<br>※ InPrivate ブラウズをご利用いただけない場合には、ログ取得前にブラウザーのキャッシュをすべて消去してください。手順は上述の補足をご覧ください。</p><p>4-2. 管理者権限でコマンド プロンプトを開き、次のコマンドを実行し、キャプチャを開始します。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　pktmon start --etw -p 0</span><br></pre></td></tr></table></figure><p>4-3. New Microsoft Edge にて該当のサイトを開き、素早く事象の再現を行う。</p><p>4-4. 次のコマンドを実行して、キャプチャを停止します</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　pktmon stop</span><br></pre></td></tr></table></figure><p>4-5. もし私共サポートから本 Blog による New Microsoft Edge の pktmon の情報採取をご依頼された場合は、トレースの .etl ファイルと C:\tmp\ssl.txt の両方とも提供します。</p><p>(参考) 以下のコマンドを実行すると、Wireshark で開ける .pcapng　形式に変換できます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pktmon pcapng PktMon.etl -o PktMon.pcapng</span><br></pre></td></tr></table></figure><hr><p>以上で今回のご紹介は終了です。</p><p>私共では様々なお客様のお問い合わせの内容や状況等に合わせて、お問い合わせ後に、Fiddler や netsh、Wireshark によるトレース、その他の情報等のご提供をお願いしております。また、多くの場合ではクライアント側のキャプチャだけでは原因究明が出来ないことも多々あり、その場合はサーバー側や中間機器等でも情報を採取いただく必要もございます。</p><p>今回はその中のあくまで 1 つである Wireshark を用いて、クライアント側のブラウザ New Microsoft Edge で動作する　Web アプリに関するネットワークトレースの取得方法をご紹介いたしました。</p><p>今回は以上です。それでは、また次回！</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font color=&quot;red&quot;&gt;2020/8/7 更新 : ブラウザーのキャッシュが利用されてキャプチャーに記録されないことを避けるために、InPrivate ブラウズをご利用いただく方法をご案内していますが、InPrivate ブラウズをご利用いただけない場合には、ロ
      
    
    </summary>
    
    
    
      <category term="ログ採取" scheme="https://jpdsi.github.io/blog/tags/%E3%83%AD%E3%82%B0%E6%8E%A1%E5%8F%96/"/>
    
      <category term="Microsoft Edge" scheme="https://jpdsi.github.io/blog/tags/Microsoft-Edge/"/>
    
      <category term="Chromium" scheme="https://jpdsi.github.io/blog/tags/Chromium/"/>
    
      <category term="Wireshark" scheme="https://jpdsi.github.io/blog/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>新しいバージョンの Microsoft Edge の &quot;IE モード&quot; について</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/IEMode/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/IEMode/</id>
    <published>2020-05-28T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:04.374Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。今回は IE モードを紹介します。</p><p>IE モードは、一言で表すと『Microsoft Edge の画面の中で Internet Explorer が動く』というものです。</p><p>構成方法などを含めた詳細は以下のドキュメントをご覧いただければと思いますが、適切に制御することで、ユーザーが Internet Explorer と Microsoft Edge を意識的に使い分ける操作をせずに、Internet Explorer を必要とする古い技術で作られた Web アプリケーションを、Microsoft Edge の中でシームレスに閲覧できるようになります。</p><p>IE モードの登場により『Internet Explorer を単独で動かすのではなく、IE/Edge どちらにも対応したブラウザー環境を提供する』ことから『今後は Internet Explorer ではなく、Microsoft Edge で動作する Web アプリケーションを用意する』というように段階的な移行を進めやすくなりました。<br>ぜひ活用していただければと思います。</p><p>IE モードの概要<br><a href="https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode</a></p><p>IE モード ポリシーの構成<br><a href="https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode-policies" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode-policies</a></p><p>エンタープライズ モード サイト リストでのサイトの構成<br><a href="https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode-sitelist" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode-sitelist</a></p><p>IE モードに関する FAQ<br><a href="https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode-faq" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode-faq</a></p><p>何か困ったことがありましたら、私たちサポート チームまでお問い合わせください。</p><hr><p>IE モードを利用するとき『認証がうまくいかない』というお問い合せをよくいただきますので、ここで紹介します。</p><p>認証がうまくいかないという話では <a href="../cross-protected-mode-cookie/">保護モードをまたいだ Cookie について</a> という記事で、Azure AD (AAD) 認証を必要とする Web アプリケーションを例としました。<br>対象の Web アプリケーションのドメインと認証時にアクセスする login.microsoftonline.com が異なったセキュリティ ゾーンに属していた場合、認証済みを示す Cookie がリクエストに含まれないことで、ユーザーがログオンしていないと判断され、再度認証を求められてしまうという現象を解説しました。</p><p>IE モードを利用するとき『どの URL を IE モードで表示するか』を設定しますが、対象の Web アプリケーションの URL に加えて、<strong><font color="red">認証サーバー / シングル サインオン サーバーに対してのアクセスも IE モードで動作するように明示的に構成する</font></strong> 必要があります。<br>認証サーバーも含めておかないと、以下のように IE モードと Edge とで行き来するときに認証に必要な Cookie が共有されずに認証ができません。</p><ol><li>対象の Web アプリケーションの URL にアクセスします。(IE モードで動作します)</li><li>認証のために認証サーバーにアクセスします。(Edge で通信します)</li><li>Edge 側で認証済みを示す Cookie を受け取ります。</li><li>対象の Web アプリケーションにリダイレクトしますが、ここで IE モードに切り替わります。</li><li>IE モードとしては認証済みを示す Cookie を持っていないので、Cookie なしの状態でリクエストすることになります。</li><li>認証済みを示す Cookie がリクエストに含まれないことで、ユーザーがログオンしていないと判断され、再度認証を求められます。</li></ol><p>ただ、認証時に通信するサーバーをすべて IE モードで動作するように明示的に指定してしまうと、逆に Edge でアクセスする必要があるパターンでうまくいきません。</p><p>具体例として、Azure AD (AAD) 認証を必要とする Web アプリケーションとして Office.com を使って試してみます。<br>(本来は IE モードを使わずに Edge でご覧いただくことをおすすめします)</p><p>まずは以下のように対象サイト (office.com) だけを登録してみます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;site url&#x3D;&quot;office.com&quot;&gt;</span><br><span class="line">    &lt;open-in&gt;IE11&lt;&#x2F;open-in&gt;</span><br><span class="line">&lt;&#x2F;site&gt;</span><br></pre></td></tr></table></figure><p>このサイト リストを読み込んで、office.com にアクセスすると IE モードで開きます。<br>サインインの操作をしてみるとわかりますが、サインインが完了しません。(場合によっては、認証画面の表示がループしてしまうこともあります)<br>これは、上述のとおり、認証済みを示す Cookie がリクエストに含まれないことで、ユーザーがログオンしていないと判断されたためです。</p><p>そこで以下のように、今回の認証時に経由する可能性がある、login.microsoftonline.com, login.windows.net, login.live.com に対しても IE モードになるように &lt;open-in&gt;IE11&lt;/open-in&gt; を設定してみます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;site url&#x3D;&quot;office.com&quot;&gt;</span><br><span class="line">    &lt;open-in&gt;IE11&lt;&#x2F;open-in&gt;</span><br><span class="line">&lt;&#x2F;site&gt;</span><br><span class="line">&lt;site url&#x3D;&quot;login.microsoftonline.com&quot;&gt;</span><br><span class="line">    &lt;open-in&gt;IE11&lt;&#x2F;open-in&gt;</span><br><span class="line">&lt;&#x2F;site&gt;</span><br><span class="line">&lt;site url&#x3D;&quot;login.windows.net&quot;&gt;</span><br><span class="line">    &lt;open-in&gt;IE11&lt;&#x2F;open-in&gt;</span><br><span class="line">&lt;&#x2F;site&gt;</span><br><span class="line">&lt;site url&#x3D;&quot;login.live.com&quot;&gt;</span><br><span class="line">    &lt;open-in&gt;IE11&lt;&#x2F;open-in&gt;</span><br><span class="line">&lt;&#x2F;site&gt;</span><br></pre></td></tr></table></figure><p>これにより、認証時に通信するサーバーすべてが IE モードで動作し、認証完了まで進みます。</p><p>それでは、この状態で <a href="https://outlook.live.com/owa/" target="_blank" rel="noopener">Outlook on the web (OWA)</a> を開いてみましょう。<br>OWA は IE モードで開くように登録をしていないので、通常の Edge で開きます。<br>サインインをしようとすると、login.live.com が IE モードとして登録されているので、サインイン画面が IE モードで開きます。<br>アカウント情報を入力してみると…</p><p>エラーになってしまいました :(</p><img src="/blog/internet-explorer-microsoft-edge/IEMode/owa.png" class=""><p>認証サーバー (login.microsoftonline.com, login.windows.net, login.live.com) を IE モードの対象から外せば、OWA は開きます。<br>でもそうすると、先ほどの Office.com がまたダメになってしまいます。</p><p>どちらもうまくいくように構成するにはどうしたらよいか…</p><p><strong><font color="red">Edge と IE のどちらからも経由され得るサイトを『ニュートラル』に登録することで解決できます！</font></strong></p><hr><p>ニュートラルの機能は、その URL に遷移してきた際の直前のブラウザーを維持することです。<br>つまり、Edge で遷移してきた場合には Edge を維持し、IE モードで遷移してきた場合には IE モードを維持するにようにできます。</p><p>それでは、先ほどのサイト リストを以下のように認証サーバー (login.microsoftonline.com, login.windows.net, login.live.com) に対してそれぞれ &lt;open-in&gt;None&lt;/open-in&gt; に変えます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;site url&#x3D;&quot;office.com&quot;&gt;</span><br><span class="line">    &lt;open-in&gt;IE11&lt;&#x2F;open-in&gt;</span><br><span class="line">&lt;&#x2F;site&gt;</span><br><span class="line">&lt;site url&#x3D;&quot;login.microsoftonline.com&quot;&gt;</span><br><span class="line">    &lt;open-in&gt;None&lt;&#x2F;open-in&gt;</span><br><span class="line">&lt;&#x2F;site&gt;</span><br><span class="line">&lt;site url&#x3D;&quot;login.windows.net&quot;&gt;</span><br><span class="line">    &lt;open-in&gt;None&lt;&#x2F;open-in&gt;</span><br><span class="line">&lt;&#x2F;site&gt;</span><br><span class="line">&lt;site url&#x3D;&quot;login.live.com&quot;&gt;</span><br><span class="line">    &lt;open-in&gt;None&lt;&#x2F;open-in&gt;</span><br><span class="line">&lt;&#x2F;site&gt;</span><br></pre></td></tr></table></figure><p>こうすると、IE モードで開く Office.com から認証サーバーにアクセスするときは IE モードが維持され、Edge で開く OWA から認証サーバーにアクセスするときは Edge が維持されますので、認証処理の途中でモードが変わってしまうことを回避できます。</p><p>なお、下記ドキュメントの「ニュートラル サイトを構成する」の部分にも記載がありますが、上記の例のように Edge と IE のどちらからも経由され得るサイトはすべてニュートラルに登録する必要があります。</p><p>エンタープライズ モード サイト リストでのサイトの構成<br><a href="https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode-sitelist" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/deployedge/edge-ie-mode-sitelist</a></p><p>一時的な対応策としては [Internet Explorer モード ページから起動したときに未構成サイトへの「ページ内」ナビゲーションの動作を指定する] というポリシーが利用できますので、状況に合わせた対応をご検討いただければと思います。</p><p>Internet Explorer モードでページ内ナビゲーションを保持する<br><a href="https://docs.microsoft.com/ja-jp/deployedge/edge-learnmore-inpage-nav" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/deployedge/edge-learnmore-inpage-nav</a></p><hr><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>アドレス バーから edge://compat/enterprise と入力してページを開くと、以下のように実際に読み込まれているサイト リストの情報を一覧できます。</p><img src="/blog/internet-explorer-microsoft-edge/IEMode/compat_enterprise.png" class=""><p>検証の際にぜひご活用ください。</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。今回は IE モードを紹介します。&lt;/p&gt;
&lt;p&gt;IE モードは、一言で表すと『Microsoft Edge の画面の中で Internet Explorer が動く』というものです。&lt;/p&gt;
&lt;p&gt;構成方法などを含めた詳細は以下のドキュメントをご覧いただければ
      
    
    </summary>
    
    
    
      <category term="Microsoft Edge" scheme="https://jpdsi.github.io/blog/tags/Microsoft-Edge/"/>
    
      <category term="IE モード" scheme="https://jpdsi.github.io/blog/tags/IE-%E3%83%A2%E3%83%BC%E3%83%89/"/>
    
  </entry>
  
  <entry>
    <title>WCF のバインディング処理にて競合状態により起きる問題</title>
    <link href="https://jpdsi.github.io/blog/web-apps/wcf-indexoutofrangeexception/"/>
    <id>https://jpdsi.github.io/blog/web-apps/wcf-indexoutofrangeexception/</id>
    <published>2020-05-26T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:06.254Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。IIS サポート チームです。</p><p>今回は WCF のバインディング処理にて競合状態により起きる問題についてご説明いたします。<br>1 つのプロセス (IIS でホストしている場合は同一アプリケーションプール) で複数の WCF のバインディングをご利用で、以下の例外とスタックトレースが記録される場合がございます。<br>これは下記コミュニティより報告があり、調査が進められた結果、弊社製品の問題と判断され、修正が検討されています。(2020/5/27 時点)</p><p>IndexOutOfRangeException in MessageSecurityOverHttpElement when creating WCF client from service reference<br><a href="https://developercommunity.visualstudio.com/content/problem/692599/indexoutofrangeexception-in-messagesecurityoverhtt.html" target="_blank" rel="noopener">https://developercommunity.visualstudio.com/content/problem/692599/indexoutofrangeexception-in-messagesecurityoverhtt.html</a></p><h2 id="例外-例外メッセージ"><a href="#例外-例外メッセージ" class="headerlink" title="例外/例外メッセージ"></a>例外/例外メッセージ</h2><p>System.IndexOutOfRangeException/インデックスが配列の境界外です。</p><h2 id="スタックトレース"><a href="#スタックトレース" class="headerlink" title="スタックトレース"></a>スタックトレース</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">場所 System.Collections.ArrayList.ArrayListEnumeratorSimple.MoveNext()</span><br><span class="line">場所 System.Configuration.PropertyInformationCollection..ctor(ConfigurationElement thisElement)</span><br><span class="line">場所 System.ServiceModel.Configuration.MessageSecurityOverHttpElement.ApplyConfiguration(MessageSecurityOverHttp security)</span><br><span class="line">場所 System.ServiceModel.Configuration.NonDualMessageSecurityOverHttpElement.ApplyConfiguration(NonDualMessageSecurityOverHttp security)</span><br><span class="line">場所 System.ServiceModel.Description.ConfigLoader.LookupBinding(String bindingSectionName, String configurationName, BindingCollectionElement bindingCollectionElement, Binding defaultBinding)</span><br><span class="line">場所 System.ServiceModel.Description.ConfigLoader.LookupBinding(String bindingSectionName, String configurationName, ContextInformation context)</span><br><span class="line">場所 System.ServiceModel.Description.ConfigLoader.LoadChannelBehaviors(ServiceEndpoint serviceEndpoint, String configurationName)</span><br><span class="line">場所 System.ServiceModel.ChannelFactory.ApplyConfiguration(String configurationName, Configuration configuration)</span><br><span class="line">場所 System.ServiceModel.ChannelFactory.InitializeEndpoint(String configurationName, EndpointAddress address)</span><br><span class="line">場所 System.ServiceModel.ChannelFactory&#96;1..ctor(String endpointConfigurationName, EndpointAddress remoteAddress)</span><br><span class="line">場所 System.ServiceModel.ConfigurationEndpointTrait&#96;1.CreateSimplexFactory()</span><br><span class="line">場所 System.ServiceModel.ClientBase&#96;1.CreateChannelFactoryRef(EndpointTrait&#96;1 endpointTrait)</span><br><span class="line">場所 System.ServiceModel.ClientBase&#96;1.InitializeChannelFactoryRef()</span><br></pre></td></tr></table></figure><p>回避策、対処方法としては以下の 2 点ございます。</p><ol><li>WCF のアプリケーションにおいてクライアントのクラスをインスタンス化を複数同時に発生しないよう排他制御を行っていただく</li><li>プロセスの再起動を行う (IIS でホストしている場合にはアプリケーションプールのリサイクル) </li></ol><p>ご不便をおかけしており誠に恐れ入りますが、何卒よろしくお願いいたします。</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。 もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。IIS サポート チームです。&lt;/p&gt;
&lt;p&gt;今回は WCF のバインディング処理にて競合状態により起きる問題についてご説明いたします。&lt;br&gt;1 つのプロセス (IIS でホストしている場合は同一アプリケーションプール) で複数の WCF のバインディングをご
      
    
    </summary>
    
    
    
      <category term="Internet Information Services" scheme="https://jpdsi.github.io/blog/tags/Internet-Information-Services/"/>
    
      <category term="WCF" scheme="https://jpdsi.github.io/blog/tags/WCF/"/>
    
  </entry>
  
  <entry>
    <title>Azure Bot Service の Portal 上の事象の調査に必要な情報</title>
    <link href="https://jpdsi.github.io/blog/azure-bot-service/bot-portal-log-collection/"/>
    <id>https://jpdsi.github.io/blog/azure-bot-service/bot-portal-log-collection/</id>
    <published>2020-05-10T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:02.898Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure Bot Service サポート チームです！  </p><p>以前 Azure Bot Service (Web App Bot もしくは Bot Channels Registration) のボットの動作に関する情報採取について以下をご紹介しましたが、今回は Azure Bot Service をご利用する際に、Azure Portal 上で問題が起こった際に必要となることが多い再現手順と通信ログの情報採取をご紹介いたします。</p><p>現象により必要な情報は異なりますが、今回はほとんどの Azure Bot Service の Portal 上の問題に関する調査に対して有効な情報について以下にご紹介いたします。</p><p>例えば、以下のような問題があげられます。</p><ul><li>Azure Portal 上にて Azure Bot Service のリソース作成時にエラーがでる</li><li>Azure Portal 上の Azure Bot Service リソースのあるパネルのページのみ正常に開けない</li></ul><br /><hr><h2 id="0-前置き"><a href="#0-前置き" class="headerlink" title="0. 前置き"></a>0. 前置き</h2><p>Azure Bot Service 作成時に出力されるエラーとして例えば以下のようなものがあり、<br>それぞれ該当する回避策を実施することで回避できる可能性がございます。<br>もし該当のエラーが出ているような場合にはまずは以下をお試しください。</p><h4 id="パターン-1-Azure-Bot-Service-作成時に-“Authorization-RequestDenied”-エラー"><a href="#パターン-1-Azure-Bot-Service-作成時に-“Authorization-RequestDenied”-エラー" class="headerlink" title="パターン 1 : Azure Bot Service 作成時に “Authorization_RequestDenied” エラー"></a>パターン 1 : Azure Bot Service 作成時に “Authorization_RequestDenied” エラー</h4><p>Azure Bot Service 作成時に “Authorization_RequestDenied” エラー が出ている<br>場合は、以下の事象に該当している可能性が高いので、下記情報をまずはご参照ください。</p><p>参考：Bot 作成時に “Authorization_RequestDenied” エラーが出力される<br><a href="https://social.msdn.microsoft.com/Forums/en-US/eecc490d-4d0a-4e8d-bc90-3f927ebe78c6/bot-authorizationrequestdenied-?forum=azurebotsupportteamja" target="_blank" rel="noopener">https://social.msdn.microsoft.com/Forums/en-US/eecc490d-4d0a-4e8d-bc90-3f927ebe78c6/bot-authorizationrequestdenied-?forum=azurebotsupportteamja</a></p><p>参考 : ボットを作成するときに Authorization_RequestDenied という例外が発生するのはなぜですか。<br><a href="https://docs.microsoft.com/ja-jp/azure/bot-service/bot-service-troubleshoot-general-problems?view=azure-bot-service-4.0#why-do-i-get-an-authorization_requestdenied-exception-when-creating-a-bot" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/azure/bot-service/bot-service-troubleshoot-general-problems?view=azure-bot-service-4.0#why-do-i-get-an-authorization_requestdenied-exception-when-creating-a-bot</a></p><h4 id="パターン-2-Azure-Bot-Service-作成時に-“Can’t-register-resource-provider-‘Microsoft-BotService’”-エラー"><a href="#パターン-2-Azure-Bot-Service-作成時に-“Can’t-register-resource-provider-‘Microsoft-BotService’”-エラー" class="headerlink" title="パターン 2 : Azure Bot Service 作成時に “Can’t register resource provider ‘Microsoft.BotService’” エラー"></a>パターン 2 : Azure Bot Service 作成時に “Can’t register resource provider ‘Microsoft.BotService’” エラー</h4><p>Azure Bot Service 作成時に “Can’t register resource provider ‘Microsoft.BotService” エラー が出ている場合は、<br>下記サイトを参考に Microsoft.BotService のリソースプロバイダーのご確認と登録を実施ください。</p><p>参考：リソース プロバイダーの登録エラーの解決<br><a href="https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/templates/error-register-resource-provider#solution-3---azure-portal" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/azure/azure-resource-manager/templates/error-register-resource-provider#solution-3---azure-portal</a></p><hr><h2 id="1-事象解消のために考えうる回避案"><a href="#1-事象解消のために考えうる回避案" class="headerlink" title="1. 事象解消のために考えうる回避案"></a>1. 事象解消のために考えうる回避案</h2><p>上記 0 に該当しない場合、もしくはそれぞれの回避策を実施しても解決しない場合、<br>本事象が一時的な問題の可能性もございますので、以下をそれぞれ実施頂き、<br>いずれかで事象が解消するかどうか、まずは以下の手順でご確認ください。</p><h3 id="確認事項-1-ブラウザのシークレットモードで確認"><a href="#確認事項-1-ブラウザのシークレットモードで確認" class="headerlink" title="確認事項 1 :ブラウザのシークレットモードで確認"></a>確認事項 1 :ブラウザのシークレットモードで確認</h3><p>一旦開いているブラウザ等を閉じ、ブラウザ (Google Chrome や Microsoft Edge など) のシークレットウィンドウにて<br>Azure Portal を新たに開き、該当の再現手順をあらためて実施した際に事象が解消するかご確認ください。</p><h3 id="確認事項-2-ポータルの言語設定を英語に変更し、確認"><a href="#確認事項-2-ポータルの言語設定を英語に変更し、確認" class="headerlink" title="確認事項 2 : ポータルの言語設定を英語に変更し、確認"></a>確認事項 2 : ポータルの言語設定を英語に変更し、確認</h3><p>上記のシークレットモードのまま、Azure Portal を開き、右上の設定アイコンの以下の操作で言語を<br>[English] に変更し、該当の再現手順をあらためて実施した際に事象が解消するかご確認ください。 </p><h3 id="確認事項-3-時間をおいて確認"><a href="#確認事項-3-時間をおいて確認" class="headerlink" title="確認事項 3 : 時間をおいて確認"></a>確認事項 3 : 時間をおいて確認</h3><p>時間を一定時間空けてから、該当の再現手順をあらためて実施した際に事象が解消するかご確認ください。 </p><p>もし上記の 3 つでも正常でない場合、以下の情報を採取しそれを基に調査方針を検討することが可能です。<br>主に、以下の手順ではクライアント側の HTTP 通信の応答と、具体的な再現時の操作状況を確認いたします。</p><hr><h2 id="情報採取-Fiddler-ログ、問題ステップ記録ツール-PSR-のログ"><a href="#情報採取-Fiddler-ログ、問題ステップ記録ツール-PSR-のログ" class="headerlink" title="情報採取 : Fiddler ログ、問題ステップ記録ツール (PSR) のログ"></a>情報採取 : Fiddler ログ、問題ステップ記録ツール (PSR) のログ</h2><p>弊社サポート対象外のツールではございますが、 Fiddler というツールを利用することで HTTPS の通信を含めたキャプチャを取得することが可能です。<br>本ツールをご利用いただくには、対象の端末に本ツールをインストールしていただく必要があります。<br>以下に、HTTPS 通信を含めたネットワークアクセスのキャプチャ手順をご案内いたします。</p><h3 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h3><h4 id="1-Fiddler-のダウンロード"><a href="#1-Fiddler-のダウンロード" class="headerlink" title="1. Fiddler のダウンロード"></a>1. Fiddler のダウンロード</h4><p>以下のサイトから、Fiddler4 をダウンロードし、トレースを取得する端末にインストールします。</p><p>Download Fiddler<br><a href="https://www.telerik.com/download/fiddler/fiddler4" target="_blank" rel="noopener">https://www.telerik.com/download/fiddler/fiddler4</a></p><h4 id="2-Portal-上の言語の変更"><a href="#2-Portal-上の言語の変更" class="headerlink" title="2. Portal 上の言語の変更"></a>2. Portal 上の言語の変更</h4><p>ポータルの言語設定を上記の確認事項 2 のように、言語設定を [英語 (English)]に変更します。<br>確認事項 1 のように、Chrome などのブラウザの [シークレットモード] で Azure Portal (<a href="https://portal.azure.com/" target="_blank" rel="noopener">https://portal.azure.com/</a>) を再度新たに開きます。<br>※ まだ再現手順は行わずに、Azure Portal 上のトップページのまま、以下の手順 3 を実施します。</p><h3 id="情報採取"><a href="#情報採取" class="headerlink" title="情報採取"></a>情報採取</h3><h4 id="3-PSR-採取開始"><a href="#3-PSR-採取開始" class="headerlink" title="3. PSR 採取開始"></a>3. PSR 採取開始</h4><p>Windows 標準の画面キャプチャソフトである問題ステップ記録ツール (PSR) を起動します。</p><p>3-1.クライアントにて、Win + R キーを押し、[ファイル名を指定して実行] より “psr” と入力し、[OK] をクリックします。</p><p>3-2. [ステップ記録ツール] が起動しましたら、右端の ▼ をクリックし、[設定] をクリックします。</p><p>3-3. [保存する最新の取り込み画像数] を “25” から “150” に変更し [OK] をクリックします。</p><p>3-4. [記録の開始] をクリックします。</p><h4 id="4-Fiddler-ログの採取と-PSR-の採取終了"><a href="#4-Fiddler-ログの採取と-PSR-の採取終了" class="headerlink" title="4. Fiddler ログの採取と PSR の採取終了"></a>4. Fiddler ログの採取と PSR の採取終了</h4><p>4-1. 接続元クライアントにて、Fiddler を起動します。</p><p>4-2. Fiddler のメニュー バーから [Tools] - [Fiddler Options] を選択します。</p><p>4-3. HTTPS タブをクリックし、”Capture HTTPS CONNECTS” および “Decrypt HTTPS traffic” のチェック ボックスをオンにし、OK ボタンをクリックし、Fiddler Options を閉じます。</p><ul><li><p>“Decrypt HTTPS traffic” のチェック ボックスをオンにすることで、以下の警告が表示されますので、Yes ボタンをクリックします。<br>“Fiddler generates a unique root CA certificate to intercept HTTPS traffic. You may choose to have Windows trust this root certificate to avoid security warnings about the untrusted root certificate. You should ONLY click ‘Yes’ on a computer used exclusively for TEST purposes.”</p></li><li><p>上記警告で Yes を選択すると、セキュリティ警告が表示されますので、”はい” を選択します。<br>これにより、個人ストア、および信頼されたルート証明機関ストアに発行者が “DO_NOT_TRUST_FiddlerRoot” である証明書が追加されます。</p></li></ul><p>4-4. 画面右側にある Filters - User Filter がオフになっていることを確認します。</p><p>4-5. Fiddler のキャプチャ画面にアクセスがトレースされていることを確認してください。</p><p>4-6. Azure Portal 上で現象を再現させます。</p><p>4-7. 現象やエラー等を確認できましたら、Fiddler のメニュー バーから [File] - [Save] - [All Sessions] を選択し、.saz 形式でログを保存します。</p><p>4-8. PSR の画面で [記録の停止] をクリックします。</p><p>4-9. PSR の画面で [保存] をクリックし、ファイルの保存場所、ファイル名を指定し、[保存] をクリックします。</p><p>4-10. Fiddler を終了します。</p><p>4-11. PSR と Fiddler で採取した情報を基に調査を行います。</p><h4 id="5-Fiddler-アンインストールについて-任意"><a href="#5-Fiddler-アンインストールについて-任意" class="headerlink" title="5. Fiddler アンインストールについて (任意)"></a>5. Fiddler アンインストールについて (任意)</h4><p>アンインストールについては下記をご参考にいただければと存じます。</p><p>5-1. コントロール パネルから [プログラムと機能] を選択します。</p><p>5-2. Fiddler をダブル クリックし、”Uninstall” ボタンをクリックしアン インストールします。</p><p>5-3. [スタート] - [検索の開始] に certmgr.msc と入力し、Enter キーを押下します。</p><p>5-4. 証明書管理スナップインの左ペインから、[個人] - [証明書] を展開し、右ペインから発行者が “DO_NOT_TRUST_FiddlerRoot” となっている全ての証明書に関して、証明書を右クリックし、”削除” を選択し、証明書を削除します。</p><p>5-5. 証明書管理スナップインの左ペインから、[信頼されたルート証明機関] - [証明書] を展開し、右ペインから発行者が “DO_NOT_TRUST_FiddlerRoot” となっている全ての証明書に関して、証明書を右クリックし、”削除” を選択し、証明書を削除します。</p><p>※ なお、Fiddler 自体のツールに関するトラブルシューティングや操作方法等のご質問は 3 rd party 製品となる為、本 Azure サポートでは承ることができませんのでご了承ください。</p><br /><p>上記を基に私共サポートにて Azure Bot Service リソースにおける Azure Portal 上の事象に関して調査を承ることが可能です。</p><p>なお、状況に応じて、例えば Azure Bot Service のそのほかの情報や詳細な画面キャプチャなど追加の情報が必要になることも多々ございますが、上記をまず確認した上で、より詳細な調査に向けて調査方針や追加の情報採取を検討していくことが可能となります。</p><p>今回は以上です。それでは、また次回！</p><br /><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。Azure Bot Service サポート チームです！  &lt;/p&gt;
&lt;p&gt;以前 Azure Bot Service (Web App Bot もしくは Bot Channels Registration) のボットの動作に関する情報採取について以下をご紹介し
      
    
    </summary>
    
    
    
      <category term="Azure Bot Service" scheme="https://jpdsi.github.io/blog/tags/Azure-Bot-Service/"/>
    
      <category term="ログ採取" scheme="https://jpdsi.github.io/blog/tags/%E3%83%AD%E3%82%B0%E6%8E%A1%E5%8F%96/"/>
    
      <category term="Azure Portal" scheme="https://jpdsi.github.io/blog/tags/Azure-Portal/"/>
    
  </entry>
  
  <entry>
    <title>Web App Bot の常時接続について</title>
    <link href="https://jpdsi.github.io/blog/azure-bot-service/bot-alwayson/"/>
    <id>https://jpdsi.github.io/blog/azure-bot-service/bot-alwayson/</id>
    <published>2020-04-22T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:02.314Z</updated>
    
    <content type="html"><![CDATA[<p>※ これまで Azure Bot Service Support Team Blog にて公開していた記事を移しました。</p><p>こんにちは。Azure Bot Service Support Team です。</p><p>Web App Bot をご利用の際に、ボットに ”暫く経ってからアクセスした際にレスポンスが遅いように感じる” といったような事がある場合があります。今回は、そんな時に事象解消の手助けができるような方法についてご紹介します。</p><p>まずはなぜ “暫く経ってからアクセスした際にレスポンスが遅いように感じる” といったことが起こるのかについて、下記にて記載させていただきます。</p><br /><hr><h2 id="考えられる原因について"><a href="#考えられる原因について" class="headerlink" title="考えられる原因について"></a>考えられる原因について</h2><p>まず、Web App Bot については、Bot アプリケーションを Azure App Service 上にホストするものです。</p><p>なお、Web App Bot などの Azure Bot Service の種類に関しては下記の前回の Blog 記事をご参照ください。</p><p>参考 : Azure Bot Service サポートチーム - Azure Bot Service の種類について<br><a href="https://social.msdn.microsoft.com/Forums/ja-JP/74ec7be1-10f9-4faf-af31-89c0d36cec6f/azure-bot-service-?forum=azurebotsupportteamja" target="_blank" rel="noopener">https://social.msdn.microsoft.com/Forums/ja-JP/74ec7be1-10f9-4faf-af31-89c0d36cec6f/azure-bot-service-?forum=azurebotsupportteamja</a></p><p>ホストする Azure App Service では一定期間アイドル状態になるとリソース節約のために、Web アプリは自動的にアンロードされるような機能が備わっております。</p><p>この機能により、システムリソースを節約できる一方で、Web アプリがアンロードされた後の最初の要求への応答が結果的に長くなります。</p><p>Web App Bot をご利用の際に ”暫く経ってからアクセスした際にレスポンスが</p><p>遅いように感じる” といった事象の原因の多くが上記の機能の影響と考えられます。</p><hr><h2 id="考えられる解決法について"><a href="#考えられる解決法について" class="headerlink" title="考えられる解決法について"></a>考えられる解決法について</h2><p>上記の機能を無効にするためには Bot をホストする Azure App Service で [常時接続] をオンにします。</p><p>具体的には、下記が [常時接続] の設定を変更する手順となります。</p><ol><li>Azure Portal で、ホストする Azure App Service のリソースに移動します。</li><li>[構成] を選択し、上部の [全般設定] タブを選択します。</li><li>[常時接続] の [On] (オン) を選択し、保存します。</li></ol><p>参考 : Azure での Web アプリのアプリケーションパフォーマンスに関するよくあるご質問 – 常時接続<br><a href="https://docs.microsoft.com/ja-jp/azure/app-service/faq-availability-performance-application-issues#how-do-i-decrease-the-response-time-for-the-first-request-after-idle-time" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/azure/app-service/faq-availability-performance-application-issues#how-do-i-decrease-the-response-time-for-the-first-request-after-idle-time</a></p><p>参考 : Azure Bot Service - 一般的な問題のトラブルシューティング – 常時接続<br><a href="https://docs.microsoft.com/ja-jp/azure/bot-service/bot-service-troubleshoot-general-problems?view=azure-bot-service-4.0#my-bot-is-slow-to-respond-to-the-first-message-it-receives-how-can-i-make-it-faster" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/azure/bot-service/bot-service-troubleshoot-general-problems?view=azure-bot-service-4.0#my-bot-is-slow-to-respond-to-the-first-message-it-receives-how-can-i-make-it-faster</a></p><p>なお、利用する App Service Plan によって制限があり、その注意点についても下記にて記載いたします。</p><h3 id="上記設定の変更に必要な-App-Service-Plan"><a href="#上記設定の変更に必要な-App-Service-Plan" class="headerlink" title="上記設定の変更に必要な App Service Plan"></a>上記設定の変更に必要な App Service Plan</h3><p>2019 年 9 月現在、上記の設定を変更するには、Basic 以上の App Service Plan が必要となります。</p><p>参考 : App Service プラン<br><a href="https://azure.microsoft.com/ja-jp/pricing/details/app-service/plans/" target="_blank" rel="noopener">https://azure.microsoft.com/ja-jp/pricing/details/app-service/plans/</a></p><p>Free や Shared の App Service Plan をご利用の場合には、Basic 以上のプランへのスケールアップをご検討ください。</p><p>参考 : Azure でのアプリのスケールアップ<br><a href="https://docs.microsoft.com/ja-jp/azure/app-service/web-sites-scale" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/azure/app-service/web-sites-scale</a></p><p>なお、Free プラン等のプランをご利用の場合は設定部分が既定のオフのままグレーアウトされます。</p><img src="/blog/azure-bot-service/bot-alwayson/lowplan.png" class=""><hr><h2 id="QnA-Maker-を連携してご利用の場合"><a href="#QnA-Maker-を連携してご利用の場合" class="headerlink" title="QnA Maker を連携してご利用の場合"></a>QnA Maker を連携してご利用の場合</h2><p>Web App Bot と QnA Maker を連携してご利用の方々も多いかと存じます。</p><p>その場合には、QnA Maker のリソースで利用している側の Azure App Service についても、上記の Web App Bot の Azure App Service と同様に、[常時接続] を ON に設定変更頂く必要がございます。</p><p>今回の内容としては以上となります。</p><p>また、全体的なレスポンスの一般的なパフォーマンス向上という観点では、App Service Plan のスケールアップも有効かと存じますので、こちらも状況に応じてご検討ください。 </p><p>参考 : Azure でのアプリのスケールアップ<br><a href="https://docs.microsoft.com/ja-jp/azure/app-service/web-sites-scale" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/azure/app-service/web-sites-scale</a></p><p>それでは、また。</p><br /><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;※ これまで Azure Bot Service Support Team Blog にて公開していた記事を移しました。&lt;/p&gt;
&lt;p&gt;こんにちは。Azure Bot Service Support Team です。&lt;/p&gt;
&lt;p&gt;Web App Bot をご利用の際に、ボ
      
    
    </summary>
    
    
    
      <category term="Azure Bot Service" scheme="https://jpdsi.github.io/blog/tags/Azure-Bot-Service/"/>
    
      <category term="Azure App Service" scheme="https://jpdsi.github.io/blog/tags/Azure-App-Service/"/>
    
      <category term="設定" scheme="https://jpdsi.github.io/blog/tags/%E8%A8%AD%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>Azure Bot Service の料金やプランについて</title>
    <link href="https://jpdsi.github.io/blog/azure-bot-service/bot-plan/"/>
    <id>https://jpdsi.github.io/blog/azure-bot-service/bot-plan/</id>
    <published>2020-04-22T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:02.802Z</updated>
    
    <content type="html"><![CDATA[<p>※ これまで Azure Bot Service Support Team Blog にて公開していた記事を移しました。</p><p>こんにちは。Azure Bot Service Support Team です。</p><p>今回は Azure Bot Service の料金やプランについて、以下の Azure Bot Service の価格のページを元に説明します。</p><p>Azure Bot Service の価格<br><a href="https://azure.microsoft.com/ja-jp/pricing/details/bot-service/" target="_blank" rel="noopener">https://azure.microsoft.com/ja-jp/pricing/details/bot-service/</a></p><p>Azure Bot Service には Free(F0) と Standard(S1) の 2 つのプランがあります。</p><img src="/blog/azure-bot-service/bot-plan/botplan.png" class=""><p>Azure ポータルから Web App Bot 等の Azure Bot Service のリソースを作成しようとした際に表示される価格レベルがこちらに当たります。</p><img src="/blog/azure-bot-service/bot-plan/portalplan.png" class=""><p>上記の通り、プランを利用することに対してかかる料金はありませんが、ユーザーと Bot がチャネルを介してやりとり (会話) するメッセージに対して、選択するプランおよびチャネルごとに料金や制限がかかります。</p><p>ここで「チャネル」という単語が出てきましたが、Azure Bot Service では開発した Bot アプリケーションを複数のチャネルを経由して利用できます。例えば、開発した Bot に対して Microsoft Teams チャネルを有効にすることで Microsoft Teams クライアントから 1 on 1 のチャットやチームのチャネルから会話でき、かつ、同じ Bot に対して LINE チャネルも有効にすることで LINE アプリからも会話するといったことができます。</p><p>チャネルには Standard チャネルと Premium チャネルの 2 種類があり、それぞれのチャネルとしては以下が用意されています (2019 年 7 月現在)。「Azure Bot Service の価格」ページの画面下部の FAQ にも少し説明がありますので、ご覧ください。</p><img src="/blog/azure-bot-service/bot-plan/channels.png" class=""><p>1 つの Bot アプリケーションに対して、複数のチャネルを有効にすることができ、また、複数のチャネルを利用しても追加の料金はありません。また、Standard チャネルを利用する場合は、プランが Free であっても Standard であっても料金はかからず、かつ、制限も変わりません。</p><p>つまり、上述の Standard チャネルのいずれかのみを介して Bot を利用する予定の場合は、Free プランを選択していただければ、Azure Bot Service に対する料金はかかりません。</p><p>一方、Premium チャネルを利用する予定がある場合は、Free プランでは月ごとにメッセージ数が 10,000 という上限があるため、その上限を超えるかどうかを元に、Free プランを選択するか、Standard プランを選択するかを検討していただく必要があります。ここで注意いただく必要がある点は以下になります。</p><p>1) メッセージ数のカウントは、ユーザーが bot に送ったメッセージの数と、bot からユーザーに送られたメッセージ数の合算になります。つまり、以下のようなやりとりが実施された場合、メッセージ数は 3 になります。</p><img src="/blog/azure-bot-service/bot-plan/chat1.png" class=""><p>2) Free プランを選択し、Premium チャネルを利用したメッセージのやりとりが月ごとの上限を超えた場合、Bot に対してメッセージが送信できないようになります (何らかの理由で Bot にメッセージが届かない場合と同様の状況となり、Bot アプリケーションにてメッセージは処理されません)。</p><img src="/blog/azure-bot-service/bot-plan/chat2.png" class=""><p>例)</p><img src="/blog/azure-bot-service/bot-plan/console429.png" class=""><p>この際、Web Chat 等でアクセスした際にブラウザーの開発者ツール (Microsoft Edge の場合は F12 キーより起動) を利用してメッセージを送付すると、以下のようなエラーが返されていることがご確認いただけます。</p><p>上記のようなメッセージが返されている場合は、Standard プランへの変更をご検討ください。</p><p>また、Premium チャネルに対しては SLA (Service Level Agreement) が適用され、もし仮に障害が発生し、下記に記載の SLA を下回るようなことがあった場合に返金の対象となりますが、こちらは Standard プランをご利用いただいた場合にのみ適用となります。</p><p>Azure Bot Service の SLA<br><a href="https://azure.microsoft.com/ja-jp/support/legal/sla/bot-service/v1_0/" target="_blank" rel="noopener">https://azure.microsoft.com/ja-jp/support/legal/sla/bot-service/v1_0/</a></p><p>上記のメッセージ数の上限や SLA を元にどちらのプランを選択されるか、ご検討ください。</p><p>なお、Azure Bot Service を利用することに対してかかる料金は以上となりますが、作成した Bot アプリケーションを配置する場所として Azure サービス (Azure Web App もしくは Azure Functions) を利用する場合や、Bot の使用量の分析やトラブルシュートに Application Insights サービスを利用する場合、また、Bot を LUIS や QnA といった自然言語処理サービスと連携する場合には、それぞれの料金が追加でかかります。</p><p>「Azure Bot Service の価格」ページの画面中部の「上記の料金とは別に、以下のリソース使用にも料金が発生します。」にも記載がありますが、こちらは次回 Azure Bot Service の種類の投稿にも記載予定ですので、ご参考いただければと思います。</p><p>それではまた。</p><br /><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;※ これまで Azure Bot Service Support Team Blog にて公開していた記事を移しました。&lt;/p&gt;
&lt;p&gt;こんにちは。Azure Bot Service Support Team です。&lt;/p&gt;
&lt;p&gt;今回は Azure Bot Service
      
    
    </summary>
    
    
    
      <category term="Azure Bot Service" scheme="https://jpdsi.github.io/blog/tags/Azure-Bot-Service/"/>
    
      <category term="料金プラン" scheme="https://jpdsi.github.io/blog/tags/%E6%96%99%E9%87%91%E3%83%97%E3%83%A9%E3%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Azure Bot Service の調査に必要な基本的な情報について</title>
    <link href="https://jpdsi.github.io/blog/azure-bot-service/bot-log-collection/"/>
    <id>https://jpdsi.github.io/blog/azure-bot-service/bot-log-collection/</id>
    <published>2020-04-21T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:02.511Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure Bot Service サポート チームです！  </p><p>弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てるのではないかということで、今回の記事の執筆に至っています。</p><p>Azure Bot Service (Web App Bot もしくは Bot Channels Registration) をご利用の場合、問題の原因はクライアントアプリケーション起因やホストする Bot アプリケーション起因、それらをホストする基盤起因、弊社管理のコネクタサーバー等多岐に渡るため、複数の情報を正確に把握し調査を進めていく必要があります。</p><p>お問い合わせいただいた後、これらの把握のために複数の情報をご提供いただくようお願いしておりますが、今回の記事で、その採取方法についてご紹介いたします！<br>現象により必要な情報は異なりますが、今回はほとんどの現象の調査に対して有効な情報について以下にご紹介いたします。</p><hr><h2 id="1-Azure-Portal-上の-Azure-Bot-Service-リソース情報について"><a href="#1-Azure-Portal-上の-Azure-Bot-Service-リソース情報について" class="headerlink" title="1. Azure Portal 上の Azure Bot Service リソース情報について"></a>1. Azure Portal 上の Azure Bot Service リソース情報について</h2><p>Azure 側での詳細な確認を行うために以下の 4 つをご提供ください。</p><p>1-1. Azure Bot Service の種類 (Web App Bot (Web アプリ ボット) か Bot Channels Registration (ボット チャンネル登録) のいずれか)<br>確認方法 : Azure Portal 上の該当の Azure Bot Service の左上のリソース名の下に記載</p><p>1-2. Azure Bot Service の “リソース名”<br>確認方法 : Azure Portal 上の該当の Azure Bot Service の左上にリソース名が記載</p><p>1-3. Azure Bot Service の  “メッセージング エンドポイント”<br>確認方法 : Azure Portal 上の該当の Azure Bot Service の [概要] パネルの欄にメッセージング エンドポイントが記載</p><img src="/blog/azure-bot-service/bot-log-collection/endpoint.png" class=""><p>1-4. (Web App Bot ご利用の場合のみ) Web App Bot  に結び付く Azure App Service のリソース名<br>確認方法 : Web App Bot の左パネルの [すべての App Service 設定] &gt; App Service の画面に遷移後の左上にリソース名が記載</p><br /><h2 id="2-Azure-Bot-Service-の設定パネルの画面"><a href="#2-Azure-Bot-Service-の設定パネルの画面" class="headerlink" title="2. Azure Bot Service の設定パネルの画面"></a>2. Azure Bot Service の設定パネルの画面</h2><p>Azure Portal 上を Azure Bot Service の [設定] パネルの画面のスクリーンショットをご提供ください。</p><br /><h2 id="3-Web-App-Bot-ご利用の場合-Bot-アプリケーションをホストする-Azure-App-Service-の構成情報"><a href="#3-Web-App-Bot-ご利用の場合-Bot-アプリケーションをホストする-Azure-App-Service-の構成情報" class="headerlink" title="3. (Web App Bot ご利用の場合)  Bot アプリケーションをホストする Azure App Service の構成情報"></a>3. (Web App Bot ご利用の場合)  Bot アプリケーションをホストする Azure App Service の構成情報</h2><p>該当の Web App Bot (Azure Bot Service) の左パネルの [すべての App Service 設定] &gt; App Service の画面に遷移 &gt; [構成] &gt; 上部タブの [アプリケーション設定] で [値を表示する] をクリックし値を表示した上で撮影</p><p>(なお、左上部の Azure App Service のリソース名が表示されるように画面全体を撮影ください)</p><img src="/blog/azure-bot-service/bot-log-collection/config.png" class=""><br /><h2 id="4-エラーが発生するチャンネルの情報と再現時の情報"><a href="#4-エラーが発生するチャンネルの情報と再現時の情報" class="headerlink" title="4. エラーが発生するチャンネルの情報と再現時の情報"></a>4. エラーが発生するチャンネルの情報と再現時の情報</h2><p>調査を行う上で、どのチャンネルで発生しているか、再現時のクライアントはどういう状態になっているのかというのは重要と考えられますので、以下の情報についてご提供ください。</p><p>4-1. エラーが発生している利用チャンネル<br>例 : Web Chat チャンネルと LINE チャンネルを利用していてどちらでもエラーが発生する</p><p>4-2. エラー再現時のクライアントのチャット画面側の会話時のスクリーンショット</p><p>4-3. 上記のエラーが発生した正確な時刻(“時分秒” で可能な限り正確な時間をご提供ください)</p><p>4-4. 上記再現後のチャンネルの正常性のスクリーンショット<br>確認方法 : Azure Portal 上の該当の Azure Bot Service リソース画面の左パネル [チャンネル] の 4-1 の発生チャンネル の正常性が “問題 (数字)” になっている場合、その問題をクリック後に出る部分を含む画面全体のスクリーンショットを撮影</p><br /><h2 id="5-Web-チャットでテストで試行時の情報について"><a href="#5-Web-チャットでテストで試行時の情報について" class="headerlink" title="5.    Web チャットでテストで試行時の情報について"></a>5.    Web チャットでテストで試行時の情報について</h2><p>Azure Bot Service では様々なチャンネルが存在しますが、一番シンプルに試せるのが Azure Portal 上の[Web チャットでテスト] という機能です。チャネル固有の機能を利用していたり、認証等を利用している場合には別のエラーが出る可能性があるため、一概にはいえませんが、一番シンプルな問題の切り分けをこちらを利用して行うことが可能です。Web チャットでテストでお試し頂き、以下について情報をご提供ください。</p><p>5-1. Azure Bot Service のリソース画面の左パネルの [Web チャット でテスト] で話しかけたときの画面全体のスクリーンショット (なお、左上部のリソース名も含まれるように画面全体を撮影ください)</p><p>5-2. 上記の Web チャットでテストで会話した時刻 (“時分秒” で可能な限り正確な時間をご提供ください)</p><p>5-3. Azure Bot Service のリソース画面の左パネルの [チャンネル] の [Web Chat] の正常性が “問題 (数字)” になっている場合、その問題をクリック後に出る部分を含む画面全体のスクリーンショット</p><p>5-4. 再現手順 (どういったことをするとエラーが出るのかの再現ステップ)</p><br /><h2 id="6-ホストしている-Bot-アプリケーションのソースコード"><a href="#6-ホストしている-Bot-アプリケーションのソースコード" class="headerlink" title="6. ホストしている Bot アプリケーションのソースコード"></a>6. ホストしている Bot アプリケーションのソースコード</h2><p>エラーの調査については、一般的に再現性があり、意図的に再現できる手順が確立できていることが重要になります。<br>弊社側での再現確認のため、再現可能なホストしている Bot アプリケーションのソースコードを以下の手順でご提供ください。</p><p>なお Web App Bot (Web アプリボット) の場合は Azure Portal 上を Web App Bot の<br>[ビルド] パネルの [ボットのソース コードをダウンロードする] より、zip ファイルをダウンロードすることが可能です。</p><img src="/blog/azure-bot-service/bot-log-collection/build.png" class=""><br /><p>上記を基に私共サポートにて調査を承ることが可能です。なお、状況に応じて、例えば Application Insights の情報など追加の情報が必要になることも多々ございますが上記をまず確認した上で、より詳細な調査に向けて調査方針や追加の情報採取を検討していくことが可能となります。</p><p>今回は以上です。それでは、また次回！</p><br /><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;こんにちは。Azure Bot Service サポート チームです！  &lt;/p&gt;
&lt;p&gt;弊社にお問い合わせいただくお客様に、スムーズな解決をご提供するためにお役に立てるのではないかということで、今回の記事の執筆に至っています。&lt;/p&gt;
&lt;p&gt;Azure Bot Servi
      
    
    </summary>
    
    
    
      <category term="Azure Bot Service" scheme="https://jpdsi.github.io/blog/tags/Azure-Bot-Service/"/>
    
      <category term="ログ採取" scheme="https://jpdsi.github.io/blog/tags/%E3%83%AD%E3%82%B0%E6%8E%A1%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>Web サーバー側でコンテンツを更新しても IE 上に反映されない (キャッシュのお話)</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/IE-Cache/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/IE-Cache/</id>
    <published>2020-04-19T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:04.200Z</updated>
    
    <content type="html"><![CDATA[<p>※ これまで Japan IE Support Team Blog にて公開していた記事を移しました。</p><p>「IE8 では Web サーバー側でファイルを更新したらすぐクライアントに反映されていたのに、IE9 以降にしたらすぐに反映されなくなった。。」というお問い合わせをいただくことがあります。<br>この現象は、IE9 以降の IE で [インターネット オプション] の [全般タブ] [インターネット一時ファイルと履歴の設定] で [自動的に確認する] (既定値) が設定されている場合に 発生することがあり、以下の技術文書でもご案内しています。</p><p>Internet Explorer 9 において Webサーバーとの通信なしでキャッシュからコンテンツを表示する場合がある<br><a href="https://support.microsoft.com/ja-jp/help/2530998" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/2530998</a></p><p>今回は、この IE の “キャッシュ” の動作について詳しくご紹介いたします。</p><hr><h2 id="まず最初に、キャッシュとは"><a href="#まず最初に、キャッシュとは" class="headerlink" title="まず最初に、キャッシュとは"></a>まず最初に、キャッシュとは</h2><p>Internet Explorer における “キャッシュ” とは、<strong>閲覧しているページを次回もっと早く表示できるように、PC に保存しておく Web ページ (html、aspx など)、画像 (jpg、gif など)、その他リソースファイル (スタイルシートファイル (.css)、JavaScript ファイル (.js)、動画や音声ファイル などなど) 等などのコピー</strong> のことです。<br>次回同じページにアクセスした時、Web サーバー側で特に更新されていなければキャッシュからファイルを取得することで、通信量を抑えたりページ表示の速度を速めたりするための仕組みです。</p><p>保存されているキャッシュは、[インターネット オプション] – [全般] タブ - 閲覧の履歴 – [設定] ボタンをクリックすると表示される [Web サイト データの設定] ダイアログ上で、[ファイルの表示] ボタンを押すと確認できます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-Cache/TemporaryInternetFiles.jpg" class=""><p>エクスプローラが起動して、以下のようにキャッシュが表示されます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-Cache/Explorer.jpg" class=""><p>いくつかの項目が表示されていますが、このうち <strong>“有効期限日時”</strong> は Web サーバーが指定してくる (具体的には、HTTP レスポンス ヘッダーの Set-Cookie ヘッダーで指定してくる) ものになります。指定がなければ、”なし” と表示されます。</p><p>一度閲覧した Web ページを次回表示した時、IE は基本的にファイル取得を以下の流れで行います。</p><p>ユーザーが Web ページのアドレスを IE のアドレスバーに入力して Enter キーを押す<br>IE は、対象のコンテンツのキャッシュがキャッシュフォルダに存在するかを確認する<br>→　キャッシュが存在していて、<br>→→　 有効期限内であればキャッシュから取得。<br>→ →　有効期限が切れていれば、Web サーバーへ更新確認 (If-Modified-Since ヘッダーを含む Get リクエスト) を行う。<br>→→→　更新確認の結果<br>→ →→→　Web サーバー側のファイルが更新されていたら、Web サーバーから取得。（ファイルをダウンロード。HTTP ステータスコード 200 OK が返る）<br>→ →→→　更新されていなければ (HTTP ステータスコード 304 Not Modified が返れば) 引き続きキャッシュから取得。</p><p>上記の流れを考えると、Web サーバー上のファイルが更新されれば Web サーバーから取得するのだから、「Web サーバー側でファイルを更新したのに、クライアントの IE で Web サイトにアクセスしても更新が反映されない。。」ということはなさそうに思われます。</p><p>が、</p><p>IE9 以降の IE では、以下両方に該当する場合、更新確認も行わずにコンテンツをキャッシュから取得するようになっています。</p><p>クライアント側の IE で [インターネット オプション] [インターネット一時ファイルと履歴の設定] で [自動的に確認する] (既定値) が設定されている<br>Web サーバー側で “有効期限日時” を指定していないコンテンツである</p><p>この動作変更は、IE9 以降 RFC2616 に準拠して、”表示の高速化、効率化のため、より積極的にキャッシュを利用する” ために行われました。</p><p>具体的には、<strong>[インターネット一時ファイルと履歴の設定] で [自動的に確認する] が設定されている場合、Web サーバーから “有効期限の指定のない” コンテンツを取得すると、IE は独自に有効期限を計算して設定し、キャッシュを作成する</strong> ようになりました。</p><p>この機能は “ヒューリスティックキャッシュ” と呼ばれます。</p><hr><p>(※) ヒューリスティック キャッシュについて</p><p>有効期限の指定のないコンテンツについて、従来の IE では限定されたリソース (画像ファイル) にのみ独自に期限を設定していましたが、IE9 以降ではキャッシュ可能な全てのリソースについて独自に期限を設定するようにしました。<br>ヒューリスティック キャッシュの詳細については、以下のブログ記事で紹介されています。</p><p>Caching Improvements in Internet Explorer 9<br><a href="https://docs.microsoft.com/en-us/archive/blogs/ie/caching-improvements-in-internet-explorer-9" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/archive/blogs/ie/caching-improvements-in-internet-explorer-9</a></p><p>ヒューリスティック キャッシュでは、以下の計算式で有効期限を算出します。最初にコンテンツを取得してキャッシュを作成するとき、算出した有効期限を設定します。</p><p>有効期間 = (最終チェック日時 - 最終更新日時) * 0.1</p><p>つまり最終チェック日時と最終更新時間の差が大きい、つまり更新されていない期間が長いコンテンツは有効期間が長く設定され、クライアントからの更新確認の頻度が下がる仕組みです。</p><p>なおエクスプローラー上では、”有効期限日時” は “なし” と表示され、IE が設定した有効期限は見ることができません。</p><hr><p>つまり、<br>例えば先ほどのエクスプローラー画面の iis-85.png の場合</p><img src="/blog/internet-explorer-microsoft-edge/IE-Cache/Cache-iis85.jpg" class=""><ul><li>最終チェック日時 :  2018/03/07 10:52</li><li>最終変更日時 : 2016/04/22 9:49</li></ul><p>であるため、キャッシュ作成時、有効期間は約 68 日間と設定されることとなります。<br>言い換えますと、IE が最初に iis-85.png を Web サーバーから取得してキャッシュを作成してから約 68 日間はキャッシュが有効期限内になり、この間に  Web サーバー側で更新しても、IE は Web サーバーへの更新確認は行わずキャッシュから取得します。</p><p>以上から、頻繁に更新したり、更新後すぐに確実にクライアントの IE に反映させたい！といったコンテンツについては、Web サーバー側で明示的に有効期限を指定されることをお勧めしています。</p><hr><h2 id="有効期限を設定していなかったコンテンツを-Web-サーバー上で更新した時、クライアントの-IE-に直ぐ反映させるにはどうすればいい？"><a href="#有効期限を設定していなかったコンテンツを-Web-サーバー上で更新した時、クライアントの-IE-に直ぐ反映させるにはどうすればいい？" class="headerlink" title="有効期限を設定していなかったコンテンツを Web サーバー上で更新した時、クライアントの IE に直ぐ反映させるにはどうすればいい？"></a>有効期限を設定していなかったコンテンツを Web サーバー上で更新した時、クライアントの IE に直ぐ反映させるにはどうすればいい？</h2><p>まず、クライアントには「IE が有効期限を独自に設定したキャッシュ」が既に存在している状態です。</p><p>[インターネット一時ファイルと履歴の設定] で [自動的に確認する] が選択されている場合、これが有効期限内であるうちは Web サーバーに更新確認を行わないので更新は反映されません。<br>Web サーバー側からは、クライアントのキャッシュを削除する方法がありません。<br>そのため、どうにかしてクライアントのキャッシュを削除する必要があります。</p><p>その他の方法として、[インターネット一時ファイルと履歴の設定] で [Web サイトを表示する度に確認する] または [Internet Explorer を表示する度に確認する] を指定すると、IE は有効期限内のコンテンツであっても Web サーバーに更新確認を行います。</p><p>キャッシュ削除の最もシンプルな方法は、ユーザー自身が [インターネット オプション] – [全般] タブから、閲覧の履歴を削除することです。</p><p>クライアント側でキャッシュを削除するには、インターネット オプション – 全般 タブ - 閲覧の履歴 の [削除] ボタンをクリックして [閲覧の履歴の削除] ダイアログから行います。</p><img src="/blog/internet-explorer-microsoft-edge/IE-Cache/DeleteBrowsingHistory.jpg" class=""><p>“キャッシュ” を削除するには、”インターネット一時ファイルおよび Web サイトのファイル” にチェックを入れて [削除] ボタンをクリックします。<br>Cookie や、フォームへの入力内容などを削除したくない場合には該当のチェックは外しても大丈夫です。</p><p>他の項目についての詳細は、以下の技術文書にてご案内しています。</p><p>Internet Explorer の閲覧履歴の表示および削除<br><a href="https://support.microsoft.com/ja-jp/help/17438/windows-internet-explorer-view-delete-browsing-history" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/17438/windows-internet-explorer-view-delete-browsing-history</a></p><p>社内の Active Directory 環境のクライアント端末を管理されているような方で、 ドメインに参加しているクライアント全部、キャッシュを削除したい、、ということであれば、 一つの手として「グループ ポリシーで [終了時に閲覧の履歴を削除する] を有効とするポリシーをクライアントに配布する」という方法もあります。<br>これが適用されたクライアントでは、IE を終了するときにキャッシュが削除されます。</p><hr><h2 id="今後、Web-サーバー側で更新したコンテンツを、すぐクライアントに反映させるためにはどうすればいい？"><a href="#今後、Web-サーバー側で更新したコンテンツを、すぐクライアントに反映させるためにはどうすればいい？" class="headerlink" title="今後、Web サーバー側で更新したコンテンツを、すぐクライアントに反映させるためにはどうすればいい？"></a>今後、Web サーバー側で更新したコンテンツを、すぐクライアントに反映させるためにはどうすればいい？</h2><p>頻繁に更新されるようなコンテンツでは、”Web サーバー側でコンテンツの有効期限を指定する” 方法をお勧めしています。<br>例えば以下のような HTTP 応答ヘッダー指定を行い、コンテンツのキャッシュの有効期限を制御します。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control : no-cache</span><br></pre></td></tr></table></figure><p>IE11 では、上記の HTTP 応答ヘッダーを含むファイルを受信すると有効期限切れのキャッシュを作成します。そのため次回アクセス時には Web サーバーへ更新確認を行い、更新されていれば Web サーバーから取得、更新がなければキャッシュから取得する、という動作になります。</p><p>なお HTTP 応答ヘッダーによる指定をクライアントのキャッシュに反映させるためには、Web サーバー側で指定を行った後、やっぱりクライアントのキャッシュを削除する必要がありますのでご注意ください。</p><p>キャッシュの有効期限を指定する HTTP 応答ヘッダーには以下があります。</p><p>Expires<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires</a><br>キャッシュを有効期限切れとする日時を指定します。</p><p>Cache-Control<br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control</a><br>キャッシュを有効とする期間 (秒) を指定します。キャッシュの作成を抑止する指定も可能です。</p><hr><h3 id="ご参考-META-タグによるキャッシュ制御の指定について"><a href="#ご参考-META-タグによるキャッシュ制御の指定について" class="headerlink" title="ご参考 : META タグによるキャッシュ制御の指定について"></a>ご参考 : META タグによるキャッシュ制御の指定について</h3><p>Web ページ (HTML、ASPX 等) 内では以下のような META 要素でキャッシュを制御できます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;META http-equiv&#x3D;cache-control content&#x3D;no-cache&gt;</span><br><span class="line">&lt;META http-equiv&#x3D;expires content&#x3D;0&gt;</span><br></pre></td></tr></table></figure><p>ただしこの指定は、”記載されている Web ページ” のみが対象であり、ページに読み込まれる .css や .js 等の Web リソースファイルに対しては有効ではありません。Web リソースファイルのキャッシュを制御するには、後述の通り Web サーバーにて設定を行う必要があります。</p><p>また Web ページにおいても、キャッシュを確実に制御されたい場合、以下の理由から META タグではなく HTTP 応答ヘッダーによる指定を強くお勧めしております。</p><p>META タグでのキャッシュ制御は、あくまでも HTML ファイル内の “タグ” で行なうものであり、” HTML ファイルを読み込んでから解釈しキャッシュの処理をする” ものです。<br>キャッシュの制御を HTML パーサーで行なうこととなるためキャッシュは一旦作成されます。SSL の場合は直接キャッシュ自体を削除し、非 SSL の場合は、期限切れのキャッシュと同等に扱われます。</p><hr><h3 id="ご参考-キャッシュの削除について"><a href="#ご参考-キャッシュの削除について" class="headerlink" title="ご参考 :キャッシュの削除について"></a>ご参考 :キャッシュの削除について</h3><p>IE のキャッシュ削除の方法として、 正式にサポートされているのは以下となります。</p><ul><li>[インターネット オプション] – [閲覧の履歴の削除] ダイアログから削除</li><li>エクスプローラでキャッシュの場所を開いて削除</li><li>キャッシュ削除のためのアプリケーションを開発、実行して削除 (※)</li></ul><p>(※) キャッシュ削除のために用意された “DeleteURLCacheEntry” API を利用したアプリケーションを作成し、実行することによって削除できます。<br>“インターネット一時ファイルおよびWebサイトのファイル” のみを削除するような処理も実装可能です。</p><p>DeleteUrlCacheEntry function<br><a href="https://docs.microsoft.com/ja-jp/windows/win32/api/wininet/nf-wininet-deleteurlcacheentry" target="_blank" rel="noopener">https://docs.microsoft.com/ja-jp/windows/win32/api/wininet/nf-wininet-deleteurlcacheentry</a></p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;※ これまで Japan IE Support Team Blog にて公開していた記事を移しました。&lt;/p&gt;
&lt;p&gt;「IE8 では Web サーバー側でファイルを更新したらすぐクライアントに反映されていたのに、IE9 以降にしたらすぐに反映されなくなった。。」というお問い
      
    
    </summary>
    
    
    
      <category term="Internet Explorer" scheme="https://jpdsi.github.io/blog/tags/Internet-Explorer/"/>
    
      <category term="キャッシュ" scheme="https://jpdsi.github.io/blog/tags/%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5/"/>
    
  </entry>
  
  <entry>
    <title>基本設定で Internet Explorer 関連の設定を配布する</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/</id>
    <published>2020-04-19T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:04.253Z</updated>
    
    <content type="html"><![CDATA[<p>※ これまで Japan IE Support Team Blog にて公開していた３つの記事を整理してまとめました。</p><p>Internet Explorer 関連の設定を、ドメインのグループ ポリシーを使用してクライアントに配布する方法についての紹介です。</p><p>以下の赤枠の部分についてを本記事で扱います。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences.png" class=""><hr><p>基本設定ポリシーにて Internet Explorer 関連の設定を構成する場合は以下の 3 つを使用します。</p><ul><li>インターネット設定 — インターネット オプションと類似の設定から構成できます</li><li>レジストリ — インターネット オプションの設定に対応するレジストリ値を配布できます</li><li>ショートカット — IEの観点では “お気に入り” を配布するときに利用できます</li></ul><p>ぞれぞれ順にみていきます。</p><hr><h2 id="インターネット設定"><a href="#インターネット設定" class="headerlink" title="インターネット設定"></a>インターネット設定</h2><p>インターネット設定は以下の手順で開きます。</p><ol><li>[グループ ポリシー管理エディター] を開きます。</li><li>[ユーザーの構成] &gt; [基本設定] &gt; [コントロール パネルの設定] &gt; [インターネット設定] を選択します。</li><li>[インターネット設定] を右クリックし、[新規作成] &gt; [Internet Explorer XX] (配布先のバージョン) を選択します。</li></ol><p>※ “Internet Explorer 11” という項目がありませんが、”Internet Explorer 10” を選択することで Internet Explorer 11 への配布が可能です。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences-New.png" class=""><hr><p><strong><font color="red">重要</font></strong><br><font color="red">各設定項目では『緑は配布する』/『赤は配布しない』を表しています。</font></p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences-New1.png" class=""><p>以下のようにファンクション キーで切り替えることができます。</p><ul><li>画面上の全項目を有効(全て緑)にする：F5</li><li>画面上の全項目を無効(全て赤)にする：F8</li><li>選択中の項目を有効にする(項目のみ緑)：項目選択中にF6</li><li>選択中の項目を無効にする(項目のみ赤)：項目選択中にF7</li></ul><p><font color="red">設定を配布するつもりのないタブを開いたとき、緑の線や丸印で表示されている項目は、”OK” ボタンで設定で閉じた時点で配布対象となります。<br>そのため、特に設定を配布する必要のない画面を開いた場合は、『キャンセル後再度編集する』か『F8で配布不可にする』ようお気をつけください。</font></p><hr><p>それでは、例としてプロキシの設定を配布する手順を紹介します。</p><p>なお、プロキシの設定については <a href="../LAN-Settings/">こちらの記事</a> で詳しく説明していますが、「よくあるお問い合わせ」に記載のとおりプロキシの情報はバイナリ データを含む複数のレジストリが自動的に同期をとりながら管理されています。<br>技術的な観点からは、これらのレジストリをまとめて配布することでプロキシの設定を行うことができますが、サポートされる方法としては、基本設定 - インターネット設定を利用することですので、以下の方法での対応をご検討ください。</p><h3 id="インターネット設定の構成手順"><a href="#インターネット設定の構成手順" class="headerlink" title="インターネット設定の構成手順"></a>インターネット設定の構成手順</h3><ol><li>上述の手順で設定画面を開きます。<img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences-New1.png" class=""></li></ol><p>先ほどお伝えしたように『緑は配布する』/『赤は配布しない』を表しています。<br>今回はプロキシの設定だけを配布しようと考えていますので、F8 キーなどで画面上に見えている『緑』の項目を『赤』に切り替えます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences-New2.png" class=""><p><font color="red">繰り返しになりますが、全般タブを (緑の項目を目にしたあと) このまま “OK” ボタンで閉じると、[スタートアップ] の設定や [終了時に閲覧の履歴を削除する] の設定も配布対象となり、意図しない設定を配布してしまうことになるのでご注意ください。</font></p><ol start="2"><li><p>次に [接続] タブを開きますが、先ほどと同様に『緑』の項目 “プロキシ サーバーを構成する…” を配布つもりがない時は以下のように『赤』に変更しておきます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences-Connection.png" class=""></li><li><p>[LAN の設定] ボタンをクリックします。<br>この例では、自動構成スクリプトのアドレスを明示的に指定したものを配布することにします。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences-LAN.png" class=""><p>pac の URL を入力し、F6 キーで『緑』にします。<br>※ [自動構成スクリプトを使用する] を構成する場合はアドレス欄を構成するのみで自動でチェックが入ります。</p></li></ol><p>ここでも、<font color="red">配布しない項目は『赤』にしておくこと</font>を忘れずに…</p><ol start="4"><li><p>最後に、いま構成した設定をクライアント環境に　“一度だけ”　適用したい場合は、[共通]　タブにおいて [1 度だけ適用し、再適用しない] にチェックを入れます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences-Common.png" class=""></li><li><p>[OK] で画面を閉じます。<br>実際に配布される項目は、グループ ポリシー オブジェクト (GPO) を選択した際に右側に表示される画面の [設定] タブにて確認できます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences-Report.png" class=""></li><li><p>クライアントに配布されたプロキシの設定をみてみましょう。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences-Result.png" class=""></li></ol><p>[自動構成スクリプトを使用する] が、手順 3 で設定した pac の URL になっています。<br>[設定を自動的に検出する] は手順 3 で『赤』にしたのでユーザーが指定した設定が上書きされずに残されています。</p><hr><h2 id="レジストリ"><a href="#レジストリ" class="headerlink" title="レジストリ"></a>レジストリ</h2><p>次に基本設定でレジストリを配布してみます。<br>先ほどの『インターネット設定』はインターネット オプションと類似の設定画面を用いて配布項目を構成 / 配布できる非常に便利な項目ですが、セキュリティ ゾーン の URL の配布に対応していません。<br>(以下の画像のように[サイト]ボタンがグレーアウトしています)</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/GroupPolicyPreferences-Security.png" class=""><p>クライアント環境に対して『ユーザーが任意に変更可能な状態』でセキュリティ ゾーンの URL を配布したい場合は、基本設定の『レジストリ項目』を構成します。</p><font color="red">※ 管理用テンプレートにある「サイトとゾーンの割り当て一覧」を構成した場合、ユーザーが手動で設定した内容は無視され、本項目で設定した内容に強制されます。インターネット オプション上の当該の項目は、グレーアウトした状態でユーザーは変更できず、かつ、本項目で設定したサイト (ドメイン) のみが表示される動作となります。このため「サイトとゾーンの割り当て一覧」を使用するかどうかは、よく検討してください。</font><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/AdministrativeTemplates.png" class=""><p><strong>前提 1 : セキュリティ ゾーンの URL が登録されるレジストリ</strong><br>各セキュリティ ゾーンのレジストリは以下のように登録されます。</p><p>場所 : HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\Domains\トップレベルドメイン\サブドメイン<br>名前 : プロトコル（http / https）<br>種類 : REG_DWORD<br>値 : 1 (ローカル イントラネット) / 2 (信頼済みサイト) / 3 (インターネット) / 4 (制限付きサイト)</p><p>例えば、”<a href="https://www.microsoft.com&quot;" target="_blank" rel="noopener">https://www.microsoft.com&quot;</a> を “信頼済みサイト” として配布した場合は以下のようになります。<br>場所 : HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\Domains\microsoft.com\www<br>名前 : https<br>種類 : REG_DWORD<br>値 : 2</p><p><strong>前提 2 : Internet Explorer セキュリテ ィ強化の構成 (IE ESC)</strong><br>サーバー　OS　には『Internet Explorer セキュリティ強化の構成 (IE ESC)』と呼ばれる機能があります。（既定は “有効” です）<br>この機能の状態により、登録 / 参照するセキュリティ ゾーンのレジストリが異なります。</p><p>有効：HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\EscDomains<br>無効：HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\Domains</p><p>配布元 / 配布先の『IE ESC』の状態が異なる状態でセキュリティ ゾーンの URL を 配布すると、登録 / 参照先が異なるため値が反映されません。<br>(後述の “レジストリ項目” の設定手順 4 で直接値を入力すると回避できます)</p><p>このため、セキュリティ ゾーンの URL をグループ ポリシーで管理する場合、配布元 / 配布先 IE ESC の 状態にご注意ください。<br>(クライアント OS には IE ESC が存在しないため “無効” と同等です）</p><p>IE ESC機能についての詳細は以下にあります。</p><p>Internet Explorer セキュリティ強化の構成による Internet Explorer のユーザー操作の変更<br><a href="https://support.microsoft.com/ja-jp/help/815141/ie-enhanced-security-configuration-changes-browsing-experience" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/815141/ie-enhanced-security-configuration-changes-browsing-experience</a></p><p>上記の前提を踏まえて実際の設定方法を紹介します。</p><hr><h3 id="基本設定のレジストリ項目の設定手順"><a href="#基本設定のレジストリ項目の設定手順" class="headerlink" title="基本設定のレジストリ項目の設定手順"></a>基本設定のレジストリ項目の設定手順</h3><p>この例では “<a href="https://www.microsoft.com&quot;" target="_blank" rel="noopener">https://www.microsoft.com&quot;</a> を信頼済みサイトに登録してみます。</p><p>※ 誤入力防止のために、登録されるレジストリ キーを直接指定して基本設定を構成する方法としています。<br>サーバー上で設定ができない場合は、手順 5 でレジストリ ([キーのパス] / [値の名前] / [値の種類] / [値のデータ]) を直接入力します（手順6/7は不要です）。</p><ol><li><p>配布元端末の IE 上にて配布する URL (ここでは <a href="https://www.microsoft.com" target="_blank" rel="noopener">https://www.microsoft.com</a>) を信頼済みサイトとして設定します。</p></li><li><p>[グループ ポリシー管理エディター]を開きます。</p></li><li><p>[ユーザーの構成] &gt; [基本設定] &gt; [Windows の設定] &gt; [レジストリ] を選択します。</p></li><li><p>[レジストリ]を右クリックし、[新規作成] &gt; [レジストリ項目] を選択します。</p></li></ol><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Registory.png" class=""><ol start="5"><li><p>最初に [全般タブ] が開かれます。[アクション] では既定の “更新” を、[ハイブ] は “HKEY_CURRENT_USER” を選択します。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Registory01.png" class=""></li><li><p>[キーのパス] 項目の […] ボタンをクリックし、[レジストリ項目ブラウザー] から予め登録したドメインを選択します。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Registory02.png" class=""></li></ol><p>※ この例ではレジストリ キーは以下のとおりです。<br>HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\Domains\microsoft.com\www</p><ol start="7"><li>画面下部に表示される [名前] / [種類] / [データ] 欄の [名前] をクリック (反転します) し、[選択] ボタンを押下します。<img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Registory03.png" class=""></li></ol><p>自動的に値が入力されます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Registory04.png" class=""><p>※ 手順 6 をせずに直接入力することも可能ですが、パスや値を間違えないように気を付けてください。</p><ol start="8"><li><p>クライアント環境に “一度だけ” 適用したい場合は、[共通] タブにおいて [1 度だけ適用し、再適用しない] にチェックを入れます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Registory05.png" class=""></li><li><p>[OK] で設定画面を閉じると、作成した設定が登録されます。(ログオン等の GPO 適用のタイミングでクライアント環境に値が反映されるようになります)</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Registory06.png" class=""></li><li><p>実際に配布される項目は、グループ ポリシー オブジェクト (GPO) を選択した際に右側に表示される画面の [設定] タブにて確認可能です。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Registory07.png" class=""></li><li><p>クライアントに配布された信頼済みサイトの設定をみてみましょう。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Registory08.png" class=""></li></ol><hr><h2 id="ショートカット"><a href="#ショートカット" class="headerlink" title="ショートカット"></a>ショートカット</h2><p>最後に、ショートカットでお気に入りを配布してみます。</p><ol><li><p>[グループ ポリシー管理エディター] を開きます。</p></li><li><p>[ユーザーの構成] &gt; [基本設定] &gt; [Windows の設定] &gt; [ショートカット] を選択します。</p></li><li><p>[ショートカット] を右クリックし、[新規作成] &gt; [ショートカット] を選択します。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Shortcut.png" class=""></li><li><p>最初に [全般タブ] が開かれます。[アクション] は既定の “更新” のままとします。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Shortcut01.png" class=""></li></ol><p>[名前] は %userprofile%\Favorites\ &lt;ショートカット名&gt; と入力します。<br>[ターゲットの種類] は “URL” を、[場所] は “&lt;完全なパスの指定&gt;” を選択します。<br>[ターゲット URL] に URL (この例では <a href="https://www.microsoft.com" target="_blank" rel="noopener">https://www.microsoft.com</a>) を指定します。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Shortcut02.png" class=""><ol start="5"><li><p>[共通タブ] の [ログインしているユーザーのセキュリティ コンテキストで実行する (ユーザー ポリシーオプション)] はそのままにしておきます。<br>クライアント環境に “一度だけ” 適用したい場合は、[共通] タブにおいて [1 度だけ適用し、再適用しない] にチェックを入れます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Shortcut03.png" class=""></li><li><p>[OK] で設定画面を閉じると、作成した設定が登録されます。(ログオン等の GPO 適用のタイミングでクライアント環境に値が反映されるようになります)</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Shortcut04.png" class=""></li><li><p>実際に配布される項目は、グループ ポリシー オブジェクト (GPO) を選択した際に右側に表示される画面の [設定] タブにて確認可能です。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Shortcut05.png" class=""></li><li><p>クライアントに配布されたお気に入りをみてみましょう。</p><img src="/blog/internet-explorer-microsoft-edge/IE-GroupPolicyPreferences/Shortcut06.png" class=""></li></ol><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;※ これまで Japan IE Support Team Blog にて公開していた３つの記事を整理してまとめました。&lt;/p&gt;
&lt;p&gt;Internet Explorer 関連の設定を、ドメインのグループ ポリシーを使用してクライアントに配布する方法についての紹介です。&lt;/p
      
    
    </summary>
    
    
    
      <category term="Internet Explorer" scheme="https://jpdsi.github.io/blog/tags/Internet-Explorer/"/>
    
      <category term="基本設定" scheme="https://jpdsi.github.io/blog/tags/%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A/"/>
    
      <category term="プロキシ" scheme="https://jpdsi.github.io/blog/tags/%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/"/>
    
  </entry>
  
  <entry>
    <title>IE のセキュリティ ゾーンについて</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/IE-SecurityZones/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/IE-SecurityZones/</id>
    <published>2020-04-19T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:04.298Z</updated>
    
    <content type="html"><![CDATA[<p>Internet Explorer の “セキュリティ ゾーン” についてお話をしたいと思います。</p><p>こちらの画面をご覧いただいたことはありますでしょうか？ [インターネット オプション] の、[セキュリティ] タブです。</p><img src="/blog/internet-explorer-microsoft-edge/IE-SecurityZones/SecurityTab.jpg" class=""><p>※ [インターネット オプション] ダイアログは、IE の [ツール] メニュー -  [インターネット オプション] をクリックすると表示されます。</p><p><strong>インターネット、ローカル イントラネット、信頼済みサイト、制限付きサイト</strong> の 4 つのアイコンが表示されていますが、これは IE の <strong>セキュリティ ゾーン</strong> を表しています。</p><hr><h2 id="“セキュリティ-ゾーン”-とは"><a href="#“セキュリティ-ゾーン”-とは" class="headerlink" title="“セキュリティ ゾーン” とは"></a>“セキュリティ ゾーン” とは</h2><p>Web サイトが 「ネットワーク上どの位置にあるか」を判定していずれかの “ゾーン” を割り当て、割り当てられたゾーンに基づいてセキュリティの管理を行う、IE 独自の機能です。</p><p>各ゾーンは、以下のようなイメージで設計されています。</p><p><strong><u>インターネット ゾーン</u></strong><br>一般的な、いわゆるインターネット上のサイトで利用されるゾーンです。悪意のあるサイトが含まれる可能性もあるため、既定でセキュリティは厳しめで、セキュリティレベルは「中高」です。</p><p><strong><u>ローカル イントラネットゾーン</u></strong><br>家庭内、社内など、内部ネットワークに存在するサイト向けのゾーンです。通常これらのサイトは信頼できる管理者によって管理されており、ユーザーがセキュリティ上の危険にさらされる可能性がほぼないことから、既定ではセキュリティは緩めでセキュリティレベルは「中低」です。</p><p><strong><u>信頼済みサイト ゾーン</u></strong><br>公開者、運営者がハッキリしていて、安全で信頼できるサイト向けのゾーンです。既定のセキュリティレベルは「中」で、4つのゾーンの中でローカル イントラネットゾーンの次に緩めです。具体的には、スクリプトの実行などが既定で許可されています。</p><p><strong><u>制限付きサイト ゾーン</u></strong><br>安全でない、信頼できないサイトを向けのゾーンです。既定のセキュリティレベルは 4 つのゾーンのうち最も厳しい、「高」で、スクリプト、ActiveX コントロールの実行や、ファイルのダウンロードなどはほぼ禁止されています。</p><p>通常、例えば <a href="http://www.microsoft.com/" target="_blank" rel="noopener">http://www.microsoft.com/</a> といった一般的な Web サイトは <strong>インターネット ゾーン</strong> と判定されます。</p><p>ユーザーが「安全で信頼できるので、このサイト上のスクリプト等は確認なしで実行してよい」と考えたサイトは、信頼済みサイトゾーン に追加することで、スクリプトなどの実行のたびに確認を求められることなく利用できます。</p><p>逆にあやしい、安全でないと判断したサイトは制限付きサイトゾーンに追加することで、アクセス時に意図せず有害なプログラムが実行されてしまったり、ウィルスを含むプログラムがダウンロードされてしまうことを防げます。</p><p><strong>ローカル イントラネットゾーン</strong> ではユーザーがサイトを追加する以外にも IE  が持つ “ローカル イントラネットゾーンの自動判別” の機能により、家庭内、企業内の Web サイトを自動で ローカル イントラネットゾーン と判断する場合もあります。自動判別については後述します。</p><hr><h2 id="表示中-Web-サイトの-セキュリティゾーンの確認方法"><a href="#表示中-Web-サイトの-セキュリティゾーンの確認方法" class="headerlink" title="表示中 Web サイトの セキュリティゾーンの確認方法"></a>表示中 Web サイトの セキュリティゾーンの確認方法</h2><p>表示している Web サイトがどのゾーンと判定されているかは、ページのプロパティ上に表示されます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-SecurityZones/Property.jpg" class=""><p>もしくは、Web サイトを表示中に インターネット オプション を開いてセキュリティタブを見てみてください。4 つのゾーンの内選択状態になっている (文字が白くなっている) ゾーンが、表示中の Web サイトが割り当てられているゾーンになります。</p><hr><h2 id="各ゾーンのセキュリティ設定について"><a href="#各ゾーンのセキュリティ設定について" class="headerlink" title="各ゾーンのセキュリティ設定について"></a>各ゾーンのセキュリティ設定について</h2><p>それぞれのゾーンには、既定で適切なセキュリティレベルが設定されています。</p><ul><li>インターネットゾーン : 中高</li><li>ローカル イントラネットゾーン : 中低</li><li>信頼済みサイトゾーン : 中</li><li>制限つきサイトゾーン : 高</li></ul><p>IE のセキュリティ設定は、スクリプト、ActiveX コントロール、ファイルのダウンロードに関するもの、その他にも多くの項目を含んでいます。セキュリティレベルではこれらの項目をまとめて設定できますが、[レベルのカスタマイズ] ボタンをクリックして表示される [セキュリティ設定] ダイアログで個別に設定も可能です。例えば、インターネットゾーンのレベルは “中高” ですが、ほとんどのセキュリティ設定はそのままにして、ActiveX コントロール関係のセキュリティだけ緩めたい、という場合には [レベルのカスタマイズ] を利用します。</p><p>個別の項目を変更すると、セキュリティのレベル には “カスタム” と表示されます。</p><p>セキュリティ関連のレジストリにつきましては、以下でご紹介しています。</p><p>上級ユーザー向けの Internet Explorer セキュリティ ゾーン関連のレジストリ エントリ<br><a href="https://support.microsoft.com/ja-jp/help/182569/internet-explorer-security-zones-registry-entries-for-advanced-users" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/182569/internet-explorer-security-zones-registry-entries-for-advanced-users</a></p><hr><h2 id="セキュリティゾーンの判定について"><a href="#セキュリティゾーンの判定について" class="headerlink" title="セキュリティゾーンの判定について"></a>セキュリティゾーンの判定について</h2><p>IE が Web サイトのゾーンを判定する仕組みについても簡単にご紹介します。</p><p>こちらに フローチャートもございますので、併せてご覧ください。</p><img src="/blog/internet-explorer-microsoft-edge/IE-SecurityZones/IESecurityZone.png" class=""><h4 id="インターネットゾーン"><a href="#インターネットゾーン" class="headerlink" title="インターネットゾーン"></a>インターネットゾーン</h4><p>ローカル イントラネットゾーン、信頼済みサイトゾーン、制限つきサイトゾーンと判定されなかった Web サイトはすべて、インターネットゾーンと判定されます。</p><p>なおインターネット オプションでは、明示的に Web サイトをインターネットゾーンに追加することはできません。グループ ポリシーの [サイトとゾーンの割り当て一覧] を利用すると、特定のサイトをインターネットゾーンに追加することが可能です。</p><h4 id="信頼済みサイトゾーン、及び-制限つきサイトゾーン"><a href="#信頼済みサイトゾーン、及び-制限つきサイトゾーン" class="headerlink" title="信頼済みサイトゾーン、及び 制限つきサイトゾーン"></a>信頼済みサイトゾーン、及び 制限つきサイトゾーン</h4><p>各ゾーンに明示的に追加されているサイトが、それぞれ該当のゾーンと判定されます。それ以外の条件で、これらのゾーンと判定されることはありません。</p><h4 id="ローカル-イントラネットゾーン"><a href="#ローカル-イントラネットゾーン" class="headerlink" title="ローカル イントラネットゾーン"></a>ローカル イントラネットゾーン</h4><p>信頼済みサイトや制限付きサイトゾーンと同様、”ローカル イントラネットゾーン” に明示的に追加されているサイトは、問答無用でローカル イントラネットゾーンと判定されます。</p><p>どのゾーンにも追加されていない Web サイトは、以下のような複数の要素を総合的に評価し、ローカル イントラネットゾーンに振り分けられるかが決まります。</p><p><strong>ローカルイントラネットゾーンの自動判別について</strong><br>IE が、どのようにローカルイントラネットゾーンを判定するかは、以下のダイアログの指定によって決まります。</p><img src="/blog/internet-explorer-microsoft-edge/IE-SecurityZones/LocalIntranet.jpg" class=""><p>※ このダイアログは、インターネット オプション のセキュリティタブ上でローカル イントラネットゾーンのアイコンをクリックし、サイト ボタンをクリックすると表示されます。</p><p>[イントラネットのネットワークを自動的に検出する]　が有効の場合、<strong>ローカル イントラネットゾーンの自動判別</strong> の機能が有効となります。</p><p>自動判別では、まずは “この端末でローカル イントラネットゾーンを有効とするかどうか” の判定が行われます。</p><p>イントラネットゾーンが無効となった端末では、サイトが自動的に “イントラネットゾーン” と判定されることがありません。</p><p>自動判別の機能によってイントラネット設定が有効となるのは以下の場合です。</p><p><u>a. クライアントがドメイン ネットワーク (※) 上に存在する場合</u></p><p>クライアントがドメインに参加している場合、”ローカル イントラネット” ゾーンは利用可能であると判定されます。なお、ドメイン ネットワーク上に存在する場合でも、ドメインに参加していないクライアント (WORKGROUP など) の場合は、 “ローカル イントラネット” ゾーンは利用不可と判断されます</p><p><u>b. クライアントがドメイン ネットワーク上に存在しない場合</u></p><p>Network Location Awareness (NLA) API を利用し、クライアントが管理されたネットワークに接続されているかを確認します。<br>管理されたネットワークに接続されていると判断された場合、”ローカル イントラネット” ゾーンが利用可能と判定します。<br>NLA の機能では、クライアントがドメインに参加していない場合や、該当ドメイン ネットワークに物理的に接続していない場合は、 管理されたネットワークに接続されていないと判断されます。<br>しかし、NLA での確認前に IE のコンポーネントによって端末がドメインに参加しているかの確認が行われます。<br>そのため、ドメインに参加している端末の場合にはドメイン ネットワークに物理的に接続されていない場合でも “ローカル イントラネット” ゾーンが利用可能と判定します。</p><p>　(※) “ドメインネットワーク” とは、ドメイン コントローラーが所属するネットワークを表します。</p><p>上記の条件に該当せず、イントラネット ゾーンを有効とできなかった場合には、IE で ホスト名のみのURL などイントラネットのサイト にアクセスすると、以下のような情報バーが表示されます。</p><img src="/blog/internet-explorer-microsoft-edge/IE-SecurityZones/NotificationBar.jpg" class=""><p>このメッセージは、”自動判別” の機能が、”イントラネットゾーン” を有効とできる条件が不足していると判断し、イントラネットゾーンを無効としたことを表します。</p><ul><li>“今後、このメッセージを表示しない” を選択すると、引き続きイントラネット設定は無効となり、ローカル イントラネットゾーンは利用できません。</li><li>“イントラネットの設定を有効にする” を選択すると、 [イントラネットのネットワークを自動的に検出する] は無効、つまり自動判別の機能は無効になり、他の 3 つのオプションが有効になります。オプションの設定によって、該当するサイトをイントラネットゾーン として利用できます。</li></ul><p>各オプションは以下のような設定です。</p><p><strong>ほかのゾーンにないローカル (イントラネット) のサイトをすべて含める</strong><br>セキュリティゾーンに明示的に登録されていないローカルサイトを “ローカルイントラネット” セキュリティ ゾーンにマップするかどうかを制御します。この設定が有効な場合、”信頼済みサイト” または “制限付きサイト” ゾーンに明示的に登録にされていないローカルサイトを “ローカル イントラネット” ゾ―ンと判断します。またこの設定が無効の場合、ローカルサイトに対するゾーン判定動作は行いません。なお、ローカルサイトとは、ドット (.) 文字を含まないホスト名のみでアクセスするサイト (<a href="http://contoso" target="_blank" rel="noopener">http://contoso</a> など) を指します。</p><p><strong>プロキシ サーバーを使用しないサイトをすべて含める</strong><br>プロキシサーバーを経由せず直接アクセスするサイト、(例えば インターネットオプション - 接続タブの LAN の設定で プロキシの例外リストに追加されているサイト等) を “ローカルイントラネット” セキュリティ ゾーンにマップするかどうかを制御します。この設定が有効な場合、プロキシサーバーを使用しないサイトは “ローカル イントラネット” ゾーンと判断されます。またこの設定が無効の場合、プロキシサーバーを使用しないサイトに対するゾーン判定動作は行いません。なお、プロキシ サーバーを構成していないシステムでは、この設定は効果がありません。</p><p><strong>すべてのネットワーク パス (UNC) を含める</strong><br>UNC を表す URL (\contosotest など) を “ローカルイントラネット” セキュリティ ゾーンにマップするかどうかを制御します。この設定が有効な場合、すべての UNC ネットワークパス (UNC) は “ローカル イントラネット” ゾーンと判断されます。この設定が無効な場合、ネットワーク パス (UNC) に対するゾーン判定は行いません。</p><hr><p>※ 補足<br>ドメインに参加しているコンピュータで [イントラネットのネットワークを自動的に検出する] オプションを有効にすると、残りの 3 つのオプションも自動的に有効になります。この動作は以下の技術情報にて公開しています。</p><p>Enabling “Automatically Detect Intranet Network” on a domain member computer will enable all the three Intranet Options automatically.<br><a href="https://support.microsoft.com/ja-jp/help/2028170/enabling-automatically-detect-intranet-network-on-a-domain-member-comp" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/2028170/enabling-automatically-detect-intranet-network-on-a-domain-member-comp</a></p><p>ただし、これら 3 つのオプションは、ローカルイントラネットゾーンが有効である場合に効くものとなります。</p><p>例えば、[イントラネットのネットワークを自動的に検出する] オプションが有効で、これによってローカルイントラネットゾーンが “無効” と判断された場合、プロキシ サーバーを使用しないサイトにアクセスしても、ローカルイントラネットゾーンではなくインターネットゾーンと判定されます。</p><hr><p>今回のお話は以上となります。</p><p>インターネット上のサイトを IE で閲覧されている時に、ActiveX コントロールやスクリプトの警告が出て煩わしかったり、面倒だと感じられることがあるかもしれないのですが、インターネットゾーンのセキュリティレベルを下げる、、といったことは危険なのでお勧めできません。本当に信頼できるサイトは信頼済みサイトゾーンに追加して利用するなど、適切にセキュリティ管理していただきながら、IE をご利用いただければと思います。</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Internet Explorer の “セキュリティ ゾーン” についてお話をしたいと思います。&lt;/p&gt;
&lt;p&gt;こちらの画面をご覧いただいたことはありますでしょうか？ [インターネット オプション] の、[セキュリティ] タブです。&lt;/p&gt;
&lt;img src=&quot;/blog
      
    
    </summary>
    
    
    
      <category term="Internet Explorer" scheme="https://jpdsi.github.io/blog/tags/Internet-Explorer/"/>
    
      <category term="セキュリティ ゾーン" scheme="https://jpdsi.github.io/blog/tags/%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3-%E3%82%BE%E3%83%BC%E3%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>ローカル エリア ネットワーク (LAN) の設定について</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/LAN-Settings/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/LAN-Settings/</id>
    <published>2020-04-19T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:04.417Z</updated>
    
    <content type="html"><![CDATA[<p>これまで Japan IE Support Team Blog にて公開していた記事のうち、プロキシ関連の記事を整理しました。<br>長い記事になってしまうため、下記の 4 つの記事に分けています。</p><p><strong>(今回の記事) ローカル エリア ネットワーク (LAN) の設定について</strong><br><a href="../ProxySettings/">IE からみるプロキシの設定について</a><br><a href="../pac/">PAC について</a><br><a href="../wpad/">WPAD について</a></p><hr><h3 id="1-ローカルエリアネットワーク-LAN-の設定"><a href="#1-ローカルエリアネットワーク-LAN-の設定" class="headerlink" title="1. ローカルエリアネットワーク(LAN) の設定"></a>1. ローカルエリアネットワーク(LAN) の設定</h3><p>プロキシの設定は、Internet Explorer のインターネット オプション - [接続] タブの [LAN の設定] ボタンから開ける [ローカル エリア ネットワーク (LAN) の設定] ダイアログで行います。</p><img src="/blog/internet-explorer-microsoft-edge/LAN-Settings/LAN-Settings.png" class=""><p>Windows 10 では、[Windows の設定] – [ネットワークとインターネット] – [プロキシ] とも連動しています。</p><img src="/blog/internet-explorer-microsoft-edge/LAN-Settings/OS-Proxy.png" class=""><p>ここでは [ローカル エリア ネットワーク (LAN) の設定] ダイアログの表示内容に沿って解説します。</p><p>なお、よくあるお問い合せについて後述しましたので、そちらもご覧いただければと思います。</p><hr><h3 id="2-プロキシサーバーの利用を構成するための設定"><a href="#2-プロキシサーバーの利用を構成するための設定" class="headerlink" title="2. プロキシサーバーの利用を構成するための設定"></a>2. プロキシサーバーの利用を構成するための設定</h3><p>プロキシ サーバーの利用を構成するための設定は大きく分けると、赤い枠で囲んだ『プロキシ自動構成 (Proxy Auto-Configuration, PAC) スクリプトを使う方法』と、青い枠で囲んだ『プロキシ サーバーのアドレスやポートを直接指定する方法』の二つがあります。</p><img src="/blog/internet-explorer-microsoft-edge/LAN-Settings/LAN-Settings2.png" class=""><p>それぞれの項目について順に説明します。</p><p><strong>(1) 自動構成</strong><br>『自動構成』の欄では、『自動構成スクリプト ファイルの取得先を自動的に検出する』か、『自動構成スクリプト ファイルの取得先を手動で指定する』かを設定します。<br>※ 自動構成スクリプト (PAC) とは、<a href="https://docs.microsoft.com/ja-jp/internet-explorer/ie11-ieak/proxy-auto-config-examples" target="_blank" rel="noopener">アクセス先の URL や IP アドレスなどの条件</a> を基に、『プロキシ サーバーを経由せずに直接通信する』か『指定したプロキシ サーバーを経由して通信する』かのどちらかの結果を返す JavaScript で記述されたファイルです。</p><p>[設定を自動的に検出する] のチェックをオンにすると、WPAD (Web Proxy Auto-Discovery) という技術を利用して、PAC ファイルの取得先 (<a href="http://contoso.com/proxy.pac" target="_blank" rel="noopener">http://contoso.com/proxy.pac</a> や <a href="http://wpad.contoso.com/wpad.dat" target="_blank" rel="noopener">http://wpad.contoso.com/wpad.dat</a> のような URL) を自動的に検出してファイルをダウンロードします。<br>自動的な検出を構成せずに、PAC ファイルの取得先を直接指定する場合には、[自動構成スクリプトを使用する] のチェックをオンにして [アドレス] 欄に PAC ファイルの取得先を入力します。</p><p><strong>(2) プロキシ サーバー</strong></p><img src="/blog/internet-explorer-microsoft-edge/LAN-Settings/LAN-Settings3.png" class=""><p>『プロキシ サーバー』の欄では、利用するプロキシ サーバーのアドレスやポートを直接指定します。<br>[LAN にプロキシ サーバーを使用する] のチェックをオンにして設定します。<br>[アドレス] には、ホスト名、FQDN名、IPアドレスが使用できます。<br>[詳細設定] ボタンを押すと、[プロキシの設定] ダイアログが表示されます。こちらについては後述します。<br>[ローカル アドレスにはプロキシ サーバーを使用しない] のチェックをオンにすると、”ローカル アドレス” でアクセスした場合に、指定されたプロキシ サーバーを経由せずに直接通信します。</p><p><u>“ローカル アドレス” とは？</u><br><a href="http://contoso" target="_blank" rel="noopener">http://contoso</a> のように、ホスト名のみで指定された宛先です。簡単な見分け方は、ピリオド (.) を含んでいるかどうかです。IP アドレス (<a href="http://192.168.1.1" target="_blank" rel="noopener">http://192.168.1.1</a> など) や FQDN (<a href="http://contoso.com" target="_blank" rel="noopener">http://contoso.com</a> など) はピリオドを含んでいるためローカル アドレスではありません。</p><p>たとえば、contoso の IP アドレスが 192.168.1.1 だったとした場合に、[ローカル アドレスにはプロキシ サーバーを使用しない] のチェックをオンにした状態で通信すると、宛先によって以下のようになります。</p><p><a href="http://contoso" target="_blank" rel="noopener">http://contoso</a><br>→ローカル アドレスなので、プロキシ サーバーを経由せずに直接通信します。</p><p><a href="http://192.168.1.1" target="_blank" rel="noopener">http://192.168.1.1</a> または <a href="http://contoso.com" target="_blank" rel="noopener">http://contoso.com</a><br>→ローカル アドレスではないので、プロキシ サーバーを経由して通信します。</p><p>(参考情報)<br>Internet Explorer Uses Proxy Server for Local IP Address Even if the “Bypass Proxy Server for Local Addresses” Option Is Turned On<br><a href="https://support.microsoft.com/en-us/help/262981/" target="_blank" rel="noopener">https://support.microsoft.com/en-us/help/262981/</a></p><p>&lt;自動日本語訳版&gt;<br>[ローカル アドレスにはプロキシ サーバを使用しない] オプションが有効であるにもかかわらず、Internet Explorer がローカル IP アドレスにプロキシ サーバーを使用する<br><a href="https://support.microsoft.com/ja-jp/help/262981/" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/262981/</a></p><p><br><br></p><p>[詳細設定] ボタンを押すと表示される [プロキシの設定] ダイアログについて説明します。</p><img src="/blog/internet-explorer-microsoft-edge/LAN-Settings/ProxySettings.png" class=""><p><strong><u>使用するプロキシのアドレス/ポート</u></strong></p><p>プロキシ サーバーのアドレスとポート番号を入力します。プロトコル (http://、ftp:// など) で始まらない場合、HTTP プロキシであると見なされます。たとえば、「proxy」と入力すると、「http://proxy」として扱われます。<br>また、すべての種類で同じプロキシ サーバー設定を使用するときは、”すべてのプロトコルに同じプロキシ サーバーを使用する” をオンにします。この場合は上のスクリーンショットでお分かりいただけるかと思いますが、HTTP に指定したプロキシ サーバー情報が適用されます。<br>(Internet Explorer 8 以降では、プロトコルの種類 gopher: は存在しません)</p><p><strong><u>次で始まるアドレスにはプロキシを利用しない</u></strong></p><p>プロキシ サーバーを経由せずにアクセスしたいアドレスを指定します。複数のアドレスを、セミコロンで区切って複数指定できます。<br>例外リストに指定可能な文字列 (最大 2064 バイト) の表記形式は以下となります。下記表記形式中の [] で括られる部分は省略可能を意味し、”” で括られる部分は固定の文字列を意味します。<br>[&lt;プロトコル スキーム&gt;”://“]&lt;ホスト名、FQDN または IP アドレス&gt;[“:”&lt;ポート番号&gt;][“;”*]<br>&lt;プロトコル スキーム&gt; は http や ftp 等のプロトコル名を指します。<br>なお、プロキシ サーバーの例外リストに指定可能なプロトコル名に特に制限はございませんが、IE がサポートする通信プロトコルは http、https、ftp のみとなります。</p><p><strong><u>例外リストにワイルドカード (*) は利用できる？</u></strong></p><p>はい。ワイルドカード (*) も利用できます。<br>例)</p><blockquote><p>*.example.com (“some.example.com” “<a href="http://www.example.com&quot;" target="_blank" rel="noopener">www.example.com&quot;</a> などにマッチ)<br>“www.*.com” (“<a href="http://www.example.com&quot;" target="_blank" rel="noopener">www.example.com&quot;</a> “<a href="http://www.department.example.com&quot;" target="_blank" rel="noopener">www.department.example.com&quot;</a> などにマッチ)<br>“<a href="http://www.example.*&quot;" target="_blank" rel="noopener">www.example.*&quot;</a> (“<a href="http://www.example.com&quot;" target="_blank" rel="noopener">www.example.com&quot;</a> “<a href="http://www.example.org&quot;" target="_blank" rel="noopener">www.example.org&quot;</a> “<a href="http://www.example.microsoft.com&quot;" target="_blank" rel="noopener">www.example.microsoft.com&quot;</a> などにマッチ)<br>“123.1*.66.*“ (“123.144.66.12” “123.133.66.15” “123.187.66.13.” などにマッチ)<br>“*contoso*“</p></blockquote><p>なお、ワイルドカードの利用は充分にご注意ください。例えば “www.*.com” をプロキシ例外として指定した場合、非常に多くのサイトが該当してしまうので、意図しないアドレスがプロキシ サーバー経由せずにアクセスしてしまった、ということになりかねません。</p><hr><h3 id="3-よくあるお問い合わせ"><a href="#3-よくあるお問い合わせ" class="headerlink" title="3. よくあるお問い合わせ"></a>3. よくあるお問い合わせ</h3><p><strong><u>複数の項目が有効だった場合の優先順位は？</u></strong><br>[インターネットオプション] - [接続]タブの設定は、複数にチェックが入っていた場合、上から順に試行されます。つまり、優先順位は以下となります。</p><ol><li>設定を自動的に検出する</li><li>自動構成スクリプトを使用する</li><li>LAN にプロキシ サーバーを使用する</li></ol><p>「自動構成スクリプトを使用する」だけが設定されている場合、指定されたアドレスで自動構成スクリプトが取得できたかどうかによって、次にダイレクト接続を試行するかどうかが決定されます。<br>自動構成スクリプトの取得に失敗した場合は、プロキシを使用せずに対象の Web サイトへの接続を試みます。<br>自動構成スクリプトの取得に成功した場合は、自動構成スクリプトから返されたプロキシに接続を試みます。この場合、当該プロキシに接続できる/できないにかかわらず、以降のダイレクト接続の試行は行いません。<br>また「LAN にプロキシ サーバーを使用する」も同時に設定されている場合、IE自動構成スクリプトの取得に失敗すると、次に「LAN にプロキシ サーバーを使用する」のプロキシを使用した接続を試みます。<br>このプロキシに接続できなかった場合は、それ以上の試行は行わず「ページを表示できません」のエラーページを表示する動作となります。</p><p><strong><u>自動構成スクリプトを取得するタイミング</u></strong><br>Windows 7 までは、IE のプロセス起動後、最初に通信を行うタイミングで IE 自身が取得します。このとき、自動構成スクリプトのキャッシュが存在する場合は、一般的な Web ページのキャッシュと同じ仕組みでキャッシュが利用されます。ブラウザーのキャッシュについては こちら で詳しく説明していますので併せてご覧いただければと思いますが、有効期限内のキャッシュが存在する場合には自動構成スクリプトを Web サーバーに取得しにいくことなしに、キャッシュされた自動構成スクリプトを利用することなどにご注意いただければと思います。</p><p>一方、Windows 8 からは、WinHTTP Web Proxy Auto-Discovery Service (WinHttpAutoProxySvc) という OS の機能 (サービス) によって自動構成スクリプトを取得するようになり、IE などのアプリケーションはその情報を参照する形になりました。Windows 7 までのように IE の起動とは関係がなくなり、OS の起動時に取得されるほか、下記の状況下で再取得が試みられます。</p><p>  (A) WinHttpAutoProxySvc サービスの再起動時 (Windows 10 Version 1803 からはサービスの再起動はできません)<br>  (B) NLA (Network Location Awareness) サービスの再起動時<br>  (C) ネットワークへの接続時 (構成変更 (ネットワークアダプタの無効化／有効化、LAN ケーブルの抜き差し) を含む)</p><p>上記の状況下で再取得が試みられますが、Windows 7 までの IE 上での動作と同様にキャッシュが利用されます。そのため、キャッシュの期限を無視して強制的に再取得をさせたい場合は、IE 側で閲覧履歴の削除をしてから上記の A ～ C いずれかを実施します。</p><p><strong><u>自動プロキシキャッシュについて</u></strong><br>“自動プロキシ キャッシュ” とは、接続先のホスト名とプロキシ サーバーを紐づけて記憶する Internet Explorer の機能です。<br>“自動構成スクリプトのファイル (pac ファイル) 自体のキャッシュ” とは異なります。</p><p>自動プロキシ キャッシュ機能では、例えば、1 回目に <a href="http://www.microsoft.com/" target="_blank" rel="noopener">http://www.microsoft.com/</a> にアクセスを行った際には自動構成スクリプトを解析し対象となるプロキシを決定する必要がありますが、2 回目以降のアクセスでは自動構成スクリプトを再度解析することなく 1 回目に得られた結果を用いプロキシに対してアクセスを試みるような高速化に関わる動作を実現しています。</p><p>たとえば、以下のような pac で、192.168.100.100 がダウンして、192.168.100.200 が利用されたというシナリオを考えます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function FindProxyForURL(url, host)</span><br><span class="line">&#123;</span><br><span class="line">if (shExpMatch(host, &quot;*.microsoft.com&quot;)) &#123;</span><br><span class="line">  return &quot;PROXY 192.168.100.100; PROXY 192.168.100.200&quot;; &#125;</span><br><span class="line"></span><br><span class="line">return &quot;DIRECT&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自動プロキシ キャッシュの機能によって *.microsoft.com へのアクセスは 192.168.100.200 を利用するということが Internet Explorer のメモリ上に保持され、プロセスを再起動するまで (※) キャッシュされた情報でプロキシへのアクセスをします。(つまり、最初から 192.168.100.200 からアクセスします)<br>※ Windows 10 Version 1607 からは、自動プロキシ キャッシュの機能の処理が WinHTTPAutoProxySvc に移動したため、Internet Explorer を再起動することでは自動プロキシ キャッシュの情報はクリアされず、WinHTTPAutoProxySvc の再起動 (または、Pac の再読み込み) でクリアされるように変わりました。</p><p>   Internet Explorer の自動プロキシ キャッシュを無効にする方法<br>   <a href="https://support.microsoft.com/ja-jp/help/271361/how-to-disable-automatic-proxy-caching-in-internet-explorer" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/271361/how-to-disable-automatic-proxy-caching-in-internet-explorer</a></p><p>これに加えて、プロキシ サーバーとの接続を確立できない場合は、当該プロキシ サーバーは「無効なプロキシ サーバー」の一覧というメモリ上で「30 分間」保持される情報として管理されるものがあります。<br>この動作により KB320507 で説明する、無効と判断したプロキシ サーバーに対しては、IE を再起動するか、30 分間経過するまでは接続を再試行しないという状態になり得ます。</p><p>   Internet Explorer が 30 分間に無効なプロキシ サーバーを再試行しません。<br>   <a href="https://support.microsoft.com/ja-jp/help/320507/internet-explorer-does-not-retry-bad-proxy-server-for-30-minutes" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/320507/internet-explorer-does-not-retry-bad-proxy-server-for-30-minutes</a></p><p><strong><u>IE11 以降における、file プロトコルでの自動構成スクリプトのアドレス指定について</u></strong><br>IE11 では、自動構成スクリプトのアドレスに file プロトコルでアドレスを指定できません。<br>例えば以下のような指定は無効で、この指定では自動構成スクリプトを利用することができません。</p><ul><li>C:\temp\proxy.pac</li><li>file://example/proxy.pac</li></ul><ul><li><p>動作変更の背景<br>もともと IE10 以前でも、上記のようなfile プロトコルによる指定は推奨されていませんでした。理由は、IE だけではなく、他のアプリケーションも自動構成スクリプトの設定を利用するものがあるためです。<br>具体的には、IE が通信に利用するモジュール “WinInet” では上の指定は有効なのですが、Windows Update などが利用する通信モジュール “WinHTTP” では、file プロトコルによる自動構成スクリプトのアドレス指定はサポートされていません。そのため、IE は問題なく自動構成スクリプトを利用でき、通信が行えても、Windows Update 等の他のアプリケーションが自動構成スクリプトを利用できず、問題が発生することがあるのです。これは以下の技術文書でも説明しています。</p><p>自動構成スクリプトの指定方法によって Windows Update が失敗する<br><a href="https://support.microsoft.com/ja-jp/help/890444" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/890444</a></p></li></ul><p>以上のような背景を踏まえ、file プロトコルでのアドレス指定は、Windows Update 等 WinHTTP を利用しているアプリケーションとの相互運用性を向上させるため、IE11から利用できなくなりました。</p><p>なお、Windows 10 Version 1607 より前の環境については、アドレス指定の見直しを進めていただく間の暫定的な対応策として、以下のレジストリを設定していただくと、IE11 でも file プロトコルでのアドレス指定が有効となります。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>キー</td><td>HKLM\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings</td></tr><tr><td>名前</td><td>EnableLegacyAutoProxyFeatures</td></tr><tr><td>種類</td><td>REG_DWORD</td></tr><tr><td>値</td><td>1</td></tr></tbody></table><p>あくまで暫定的な対応のために用意された方法であり、<font color="red">Windows 10 Version 1607 からはこの方法は利用できません。</font>お手数をおかけしますが、自動構成スクリプトは http または https プロトコルでアクセス可能な Web サーバーに配置してご利用いただけますようお願いいたします。</p><p><strong><u>プロキシサーバーの設定を、外部のアプリケーションやスクリプトなどから変更したい</u></strong><br>WinINet というモジュールに含まれる公開 API の InternetSetOption 関数を利用することでプロキシ サーバーの設定を行うことができます。</p><p> InternetSetOptionW function<br> <a href="https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetsetoptionw" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/api/wininet/nf-wininet-internetsetoptionw</a></p><p>実装例は以下のドキュメントにありますので併せてご覧ください。</p><p> Setting and Retrieving Internet Options<br> <a href="https://docs.microsoft.com/en-us/windows/desktop/WinInet/setting-and-retrieving-internet-options" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/desktop/WinInet/setting-and-retrieving-internet-options</a><br>  ※ 「Setting Connection Options」の部分です。</p><p>なお、プロキシの情報は下記の DefaultConnectionSettings とそれに関連する複数のレジストリが自動的に同期をとりながら管理されています。</p><p>HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\Connections\DefaultConnectionSettings<br>HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\AutoConfigURL<br>HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\ProxyEnable<br>HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\ProxyOverride<br>HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\ProxyServer</p><p>DefaultConnectionSettings はフォーマットが非公開のバイナリー データであり、基本的にはこれらのレジストリが直接編集されることは想定しておらず、たとえば、ProxyEnable や ProxyOverride などを個別に直接変更するとレジストリ間で不整合が生じて予期しない動作 (プロキシの設定が消えてしまったり、想定した通信にならないなど) となる場合があります。<br>技術的な観点からは、これらのレジストリをまとめて配布することでプロキシの設定を行うことができますが、サポートされる方法としては、上記の InternetSetOption 関数を利用することです。</p><p>以上です。</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;これまで Japan IE Support Team Blog にて公開していた記事のうち、プロキシ関連の記事を整理しました。&lt;br&gt;長い記事になってしまうため、下記の 4 つの記事に分けています。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(今回の記事) ローカル エリア ネットワー
      
    
    </summary>
    
    
    
      <category term="Internet Explorer" scheme="https://jpdsi.github.io/blog/tags/Internet-Explorer/"/>
    
      <category term="プロキシ" scheme="https://jpdsi.github.io/blog/tags/%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/"/>
    
  </entry>
  
  <entry>
    <title>IE からみるプロキシの設定について</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/ProxySettings/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/ProxySettings/</id>
    <published>2020-04-19T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:04.999Z</updated>
    
    <content type="html"><![CDATA[<p>これまで Japan IE Support Team Blog にて公開していた記事のうち、プロキシ関連の記事を整理しました。<br>長い記事になってしまうため、下記の 4 つの記事に分けています。</p><p><a href="../LAN-Settings/">ローカル エリア ネットワーク (LAN) の設定について</a><br><strong>(今回の記事) IE からみるプロキシの設定について</strong><br><a href="../pac/">PAC について</a><br><a href="../wpad/">WPAD について</a></p><hr><p>昨今、インターネットの通信をする機能や製品が多くなっており、「プロキシの設定」についてお問合せを頂く事があります。</p><p>プロキシの設定については “インターネットオプション – 接続 – LAN の設定” があります。</p><p>この設定「どのように管理されており、アプリケーションがどのようにこの設定を利用するか」ご存知でしょうか？この Blog では以下の目次の内容に沿って、この “プロキシの設定について” の理解を深めて頂ければと思います。</p><ol><li>はじめに ～ HTTP 通信に利用されるモジュール ～</li><li>インターネットオプションのプロキシ設定は誰のもの？</li><li>IE の設定はいつどのように設定値が利用されるのか</li><li>プロキシの設定についてよくある質問</li></ol><hr><h3 id="1-はじめに-～-HTTP-通信をするモジュール-～"><a href="#1-はじめに-～-HTTP-通信をするモジュール-～" class="headerlink" title="1. はじめに ～ HTTP 通信をするモジュール ～"></a>1. はじめに ～ HTTP 通信をするモジュール ～</h3><p>弊社から提供している HTTP の通信を行うモジュールには以下の 2 つがあります。</p><p>wininet.dll : 主にデスクトップにログインしたユーザーの権限で動くアプリケーションで利用する事を目的として作成されているモジュール。<br>winhttp.dll : 主にサービスなどログインをせずバックグラウンドで利用される事を目的として作成されているモジュール。</p><p>これらの 2 つのモジュールの API は一般向けにも公開されており、弊社製品以外でも様々なアプリケーションやサービスで利用することができます。</p><p>なお、IE はデスクトップでログオンし動作するアプリケーションであり、wininet.dll を利用しています。</p><hr><h3 id="2-インターネットオプションのプロキシ設定は誰のもの？"><a href="#2-インターネットオプションのプロキシ設定は誰のもの？" class="headerlink" title="2. インターネットオプションのプロキシ設定は誰のもの？"></a>2. インターネットオプションのプロキシ設定は誰のもの？</h3><p>プロキシの設定を行う際、よく目にするのは “IE の設定” として管理されている以下のインターネットオプションの画面になるとおもいます。</p><img src="/blog/internet-explorer-microsoft-edge/ProxySettings/LAN-Settings.png" class=""><p>弊社製品では多くの設定情報をレジストリに管理しており、代表的なものに「端末全体で共通した設定」を保持する場所(HKEY_LOCAL_MACHINE/HKLM)と、「ユーザー毎に行われた設定」を保持する場所が (HKEY_CURRENT_USER/HKCU)が存在します。</p><p>インターネットオプションで設定したプロキシの設定は、基本的には「ユーザー毎の情報」として HKCU で保存・維持管理されます。</p><img src="/blog/internet-explorer-microsoft-edge/ProxySettings/datastore.png" class=""><p>詳細については別の機会に譲りますが、このプロキシ設定は以下のような複数のレジストリキー配下にある複数の値を連動させて設定を管理するようになっています。</p><p>キー : HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings<br>キー : HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\Connections</p><hr><h3 id="3-IE-の設定はいつどのように設定値が利用されるのか"><a href="#3-IE-の設定はいつどのように設定値が利用されるのか" class="headerlink" title="3. IE の設定はいつどのように設定値が利用されるのか"></a>3. IE の設定はいつどのように設定値が利用されるのか</h3><p>上記の IE の設定はもちろん IE が通信を行う際に参照され利用されます。</p><p>では、その他のアプリケーションや機能ではどうでしょうか？</p><p>IE の管理するインターネットオプションから設定されたプロキシの設定を『利用するか否か』や『どのように利用するか』は各アプリケーションや機能の実装内容に依存します。</p><p>例えば、以下のようなシナリオが考えられます。</p><ul><li>IE と同様の通信モジュールである wininet.dll を利用しており、IE で設定された値をそのまま利用している</li><li>wininet.dll は利用しているが、プロキシの設定については独自の実装を行っており別に管理されている</li><li>サービスなど向けに用意されている winhttp.dll を利用しており、IE の設定を参照しその値を利用するようにしている</li><li>winhttp.dll を利用しているがサービスとして動作しており、(IEでプロキシの設定を行った)ユーザーの権限で動作しないため他の設定を (netsh コマンドで設定されたプロキシの値)が参照される</li><li>wininet/winhttp のいずれも利用していないが、プロキシの設定は IE の設定値をレジストリから参照しその情報を利用している</li><li>wininet/winhttp のいずれも利用しておらず、完全に独自の実装が行われている</li></ul><p>アプリケーションなどの実装によっては動作シナリオによって動きを柔軟に変化させられるよう上記の中の動作を組み合わせられていることなどもあります。<br>昨今ではサードパーティ製品も含めインターネットに接続し通信する機能やアプリケーションも増えており、一概に「いつどのように利用されるのか」をお伝えすることができません。</p><p>“IE の管理する” プロキシの設定値をどのように参照し利用するかについては個々のアプリケーションなどの実装についての確認をする必要があります。</p><p><u>ご参考</u></p><p>本題とは外れますが、上記に記載する wininet.dll や Winhttp.dll についてより知りたいという場合は、以下のような公開情報もご参照下さい。</p><p>Win32 Internet Extensions (WinInet)<br><a href="https://docs.microsoft.com/en-us/cpp/mfc/win32-internet-extensions-wininet?view=vs-2019" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/cpp/mfc/win32-internet-extensions-wininet?view=vs-2019</a></p><p>About WinHTTP<br><a href="https://docs.microsoft.com/en-us/windows/win32/winhttp/about-winhttp" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/winhttp/about-winhttp</a></p><p>WinINet vs. WinHTTP<br><a href="https://docs.microsoft.com/en-us/windows/win32/wininet/wininet-vs-winhttp" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/wininet/wininet-vs-winhttp</a></p><hr><h3 id="4-プロキシの設定についてよくある質問"><a href="#4-プロキシの設定についてよくある質問" class="headerlink" title="4. プロキシの設定についてよくある質問"></a>4. プロキシの設定についてよくある質問</h3><p>Q:<br>システムアカウントで動作するサービスがあるので、このアカウント用に(インターネットオプションからの設定と同等の) IE の設定を行いたいです。できますか？</p><p>A:<br>いいえ。IE の観点ではサポート可能な方法はありません。<br>前項で記載の通り、プロキシの設定の参照／利用の動作については対象のアプリケーションやサービス内での実装に依存します。<br>IE 自体はデスクトップなどにログオンしたユーザーが利用することを想定し開発されており、システムアカウントで IE を動作させること自体を想定していません。この為、システムアカウント用のプロキシの設定方法については IE の観点ではサポート可能な適切な方法がないという状況になります。</p><p>プロキシの設定の参照動作について、対象の製品／機能の観点での確認が必要な場合、弊社製の場合は対象の機能や製品の観点でのお問合せ、他社製品の場合には提供元へのお問合せなどをご検討下さい。</p><p>なお、以下の公開情報の通り IE 内部で利用している通信モジュールの wininet.dll はサービスなどのユーザーがログオンしない状態でのバックグラウンドでの利用はサポートしていません。</p><p>[INFO] サービスでは WinInet の使用はサポートされない<br><a href="https://support.microsoft.com/ja-jp/help/238425/info-wininet-not-supported-for-use-in-services" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/238425/info-wininet-not-supported-for-use-in-services</a></p><p><br><br><br>Q:<br>インターネットオプションのプロキシの設定を変更した場合の影響範囲は？</p><p>A:<br>「影響範囲」の内容が「どの程度の対象のアプリケーションがこの変更により動作が変わる可能性があるのか」であるとした場合、大変恐縮ながら “IE の観点” ではお答えすることができません。</p><p>ただし、すべてのアプリケーションや機能において事前に把握し動作を確認することも難しいかと思います。</p><p>設定変更に伴い「通信できなくなる」などの弊害が発生しないかについては、テスト環境などでもご確認をいただき特に弊社製品で何かお困りの状況が発生する場合には、専門の担当からのご支援も含め調整をいたしますのでお問い合わせください。</p><p><br><br><br>Q:<br>インターネットオプションで設定をしたプロキシはいつ利用されますか？</p><p>A:<br>もちろん “IE が利用する” 場合にはこの設定を使って通信しますが、”IE 以外” という観点では直接的が難しい部分です。</p><p>様々なアプリケーションやサービスが wininet や winhttp を利用して通信する可能性がありますが、IE で管理する設定を利用するか否か、いつ通信を行うかはそのアプリケーションやサービスに依存する為です。</p><p>実際の通信は上記のようなモジュールを利用していなくても、設定値のみ参照し独自のモジュールで実施する通信時に利用することもできます。</p><p>普段よく見かけるようでいて、あまり詳細を目にすることのない上記のような情報を何かお困りごとのある場合の検討材料や方向性のご検討にお役立ていただければ幸いです。</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;これまで Japan IE Support Team Blog にて公開していた記事のうち、プロキシ関連の記事を整理しました。&lt;br&gt;長い記事になってしまうため、下記の 4 つの記事に分けています。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../LAN-Settings/&quot;&gt;ローカ
      
    
    </summary>
    
    
    
      <category term="Internet Explorer" scheme="https://jpdsi.github.io/blog/tags/Internet-Explorer/"/>
    
      <category term="プロキシ" scheme="https://jpdsi.github.io/blog/tags/%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/"/>
    
  </entry>
  
  <entry>
    <title>PAC ファイルについて</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/pac/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/pac/</id>
    <published>2020-04-19T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:04.796Z</updated>
    
    <content type="html"><![CDATA[<p>これまで Japan IE Support Team Blog にて公開していた記事のうち、プロキシ関連の記事を整理しました。<br>長い記事になってしまうため、下記の 4 つの記事に分けています。</p><p><a href="../LAN-Settings/">ローカル エリア ネットワーク (LAN) の設定について</a><br><a href="../ProxySettings/">IE からみるプロキシの設定について</a><br><strong>(今回の記事) PAC について</strong><br><a href="../wpad/">WPAD について</a></p><hr><p>PAC ファイルを利用する場合、[インターネット オプション] – [接続] タブ – [LAN の設定] から以下のダイアログを開き、赤枠で囲った設定を有効とします。</p><p>なお、[アドレス] の項目には、PAC ファイルへの URL を記載する必要があります。ここが、WPAD とは異なる点です。WPAD を利用する場合は、URL の指定などは必要ありません。一方、PAC ファイルを利用する場合は、端末を利用するユーザーごとに PAC ファイルへの URL を明示的に設定する必要があります。</p><img src="/blog/internet-explorer-microsoft-edge/pac/LANSettings.jpg" class=""><hr><h3 id="1-自動構成スクリプト-PAC-ファイルの書き方について"><a href="#1-自動構成スクリプト-PAC-ファイルの書き方について" class="headerlink" title="1. 自動構成スクリプト (PAC) ファイルの書き方について"></a>1. 自動構成スクリプト (PAC) ファイルの書き方について</h3><p>PAC ファイルでは、「アクセス先の URL などの情報を元に、利用するプロキシ サーバーを指定する」ための処理条件をスクリプトで記載します。スクリプトの処理内では、URL のホスト名や IP アドレスなどの条件に合ったプロキシ サーバーの宛先 (URL、もしくは IP アドレス) とポート番号を返します。</p><p>PAC ファイルを記載する場合は、必ず FindProxyForURL 関数を記載する必要があります。PAC ファイルの処理時には、この FindProxyForURL の関数が実行されます。</p><p>FindProxyForURL 関数の第一引数である url はアクセス先の URL、第二引数である host はアクセス先の URL から取得したホスト名を表します。例えば、<a href="http://www.bing.com/" target="_blank" rel="noopener">http://www.bing.com/</a> という URL にアクセスする際には、url が <a href="http://www.bing.com/" target="_blank" rel="noopener">http://www.bing.com/</a> 、host が <a href="http://www.bing.com" target="_blank" rel="noopener">www.bing.com</a> となります。これらの値を様々な関数を用い条件分けし、最終的に経由するサーバーを返す (return) するような処理を作成します。以下に PAC ファイルの具体例を挙げて、ご説明します。</p><p><strong>PAC ファイルの具体例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function FindProxyForURL (url, host) &#123;</span><br><span class="line"> if (isPlainHostName (host)) &#123;</span><br><span class="line">    return &quot;DIRECT&quot;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  if (shExpMatch(url, &quot;http:&#x2F;&#x2F;www.bing.com&#x2F;&quot;)) &#123;</span><br><span class="line">      return &quot;PROXY www.bing-proxy.com:6060&quot;;</span><br><span class="line">    &#125; else if (shExpMatch(url, &quot;http:&#x2F;&#x2F;www.microsoft.com&#x2F;&quot;)) &#123;</span><br><span class="line">      return &quot;PROXY www.microsoft-proxy.com:7070&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return &quot;PROXY www.other-proxy.com:8080&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の PAC ファイルには、isPlainHostName 関数と shExpMatch 関数が記載されています。isPlainHostName 関数は host に “.” (ピリオド) が含まれていなければ true、含まれていれば false を返す関数です。shExpMatch 関数は、文字列の部分比較を行う関数であり、第一引数で与えられた文字列が、シェル表現パターンを使用した第二引数で与えられた文字列にマッチする場合は true、マッチしない場合は false を返します。</p><p>上記の PAC ファイルを使用して <a href="http://www.bing.com/" target="_blank" rel="noopener">http://www.bing.com/</a> にアクセスした場合の戻り値は <a href="http://www.bing-proxy.coom" target="_blank" rel="noopener">www.bing-proxy.coom</a> というプロキシ サーバーに 6060 番ポート、<a href="http://www.google.com/" target="_blank" rel="noopener">http://www.google.com/</a> にアクセスした場合の戻り値は <a href="http://www.other-proxy.com" target="_blank" rel="noopener">www.other-proxy.com</a> というプロキシ サーバーに 8080 番ポートでアクセスします。IE では、この戻り値の結果に応じ、対象となるプロキシ サーバーへの接続を試み、接続が確立できる場合にはプロキシ サーバー経由で HTTP の通信が行われます。  </p><p>なお、host にピリオドが含まれていない場合は、isPlainHostName が true になり、”return DIRECT” が戻り値となります。IE では “return DIRECT” が戻り値として返された場合は、プロキシ サーバーを経由せずに直接接続する動作となります。</p><p>PAC ファイルで使用できる関数は <a href="https://docs.microsoft.com/ja-jp/internet-explorer/ie11-ieak/proxy-auto-config-examples" target="_blank" rel="noopener">こちらの弊社公開情報に記載されています</a> ので、ご参考いただけますと幸いです。</p><hr><h3 id="2-PAC-ファイルの配置方法について"><a href="#2-PAC-ファイルの配置方法について" class="headerlink" title="2. PAC ファイルの配置方法について"></a>2. PAC ファイルの配置方法について</h3><p>上記の方法で作成した PAC ファイルは、Web サーバーへ配置することで利用することができます。PAC ファイルへの URL を、[インターネット オプション] の [自動構成スクリプトを使用する] の項目に記載します。</p><p>なお、PAC ファイルを配置した Web サーバーには、.pac の拡張子に対する MIME タイプを併せて設定する必要があります。</p><p>　拡張子：.pac<br>　MIME の種類：application/x-ns-proxy-autoconfig<br>　※ 適切な指定を行っていない場合には、適切に PAC ファイルを解析し、条件判断をすることができなくなりますので、ご注意ください。</p><p>PAC ファイルは、通常の Web サイトと同様に HTTP 通信の GET リクエストで取得します。そのため、HTML コンテンツと同様にクライアントにキャッシュされますので、通信時に毎回取得する動作にはなりません。なお、Web のキャッシュと同じフォルダに保存されますので、IE のキャッシュを消去することで、PAC ファイルのキャッシュも消去されます。</p><hr><h3 id="3-PAC-ファイルに関するよくあるお問い合わせ"><a href="#3-PAC-ファイルに関するよくあるお問い合わせ" class="headerlink" title="3. PAC ファイルに関するよくあるお問い合わせ"></a>3. PAC ファイルに関するよくあるお問い合わせ</h3><p>ここでは、PAC ファイルに関連してよくお問い合わせいただく事例を紹介します。</p><p><strong>3-1. PAC ファイルを使用した場合に Web サイトへのアクセスに時間がかかる場合がある</strong></p><p>PAC ファイルを利用する場合に、Web ページへのアクセスに時間がかかるというお問い合わせをいただきます。この事象は、PAC ファイル内で URL を解析する処理を行っている際に発生する DNS の名前解決に失敗し、発生している可能性があります。</p><p>PAC ファイル内で以下の関数を利用する際には、DNS への名前解決が発生します。<br>・isResolvable<br>・isInNet<br>・dnsResolve</p><p>DNS サーバーへ問題なくアクセスができ、かつ名前解決にも成功する場合は、基本的に Web ページへのアクセスに時間がかかることはありません。しかし、DNS サーバーへのアクセスに失敗した場合や、アクセスは成功しても名前解決に失敗する場合は、その過程で時間がかかってしまうため、Web ページへのアクセスに時間がかかってしまいます。</p><p>そのため、PAC ファイル内で上記の関数を利用している環境で Web ページへのアクセスに時間がかかる場合は、DNS サーバーへの通信が正常に行えているかをご確認いただくのが有効です。</p><p><strong>3-2. “ローカル イントラネット” ゾーンの Web サイトが “インターネット” ゾーンと判断される場合がある</strong></p><p>PAC ファイルの解析結果は、セキュリティ ゾーンの自動判定にも使用されます。具体的には、PAC ファイルで “return DIRECT” が戻り値となる URL、つまり直接接続を行う Web サイトは “ローカル イントラネット” ゾーンとして表示されます。しかし、直接接続を行っているにもかかわらず、Web サイトが “インターネット” ゾーンとして表示されてしまうというお問い合わせをいただきます。この事象は、セキュリティ ゾーンの判定処理と PAC ファイルを取得/解析する処理が完了するタイミングによって発生します。</p><p>この事象は、[インターネット オプション] の [セキュリティ] タブから、Web サイトを明示的に “ローカル イントラネット” ゾーンに登録することで回避されます。明示的なゾーン登録を行うことで、PAC ファイルを使用したセキュリティ ゾーンの自動判定処理が行われず、Web サイトは必ず “ローカル イントラネット” ゾーンとして判定されます。</p><p>上記の事象については以下のサポート技術文書にも記載されておりますので、ご参考ください。</p><p>　FQDN または IP アドレスを使用すると、イントラネット サイトがインターネット サイトとして識別される<br>　<a href="https://support.microsoft.com/ja-jp/help/303650/" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/303650/</a></p><p>PAC ファイルをうまく活用することでネットワーク管理も容易になりますので、ぜひご利用ください！</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;これまで Japan IE Support Team Blog にて公開していた記事のうち、プロキシ関連の記事を整理しました。&lt;br&gt;長い記事になってしまうため、下記の 4 つの記事に分けています。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../LAN-Settings/&quot;&gt;ローカ
      
    
    </summary>
    
    
    
      <category term="Internet Explorer" scheme="https://jpdsi.github.io/blog/tags/Internet-Explorer/"/>
    
      <category term="プロキシ" scheme="https://jpdsi.github.io/blog/tags/%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/"/>
    
      <category term="pac" scheme="https://jpdsi.github.io/blog/tags/pac/"/>
    
  </entry>
  
  <entry>
    <title>WPAD について</title>
    <link href="https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/wpad/"/>
    <id>https://jpdsi.github.io/blog/internet-explorer-microsoft-edge/wpad/</id>
    <published>2020-04-19T15:00:00.000Z</published>
    <updated>2020-11-25T00:44:05.161Z</updated>
    
    <content type="html"><![CDATA[<p>これまで Japan IE Support Team Blog にて公開していた記事のうち、プロキシ関連の記事を整理しました。<br>長い記事になってしまうため、下記の 4 つの記事に分けています。</p><p><a href="../LAN-Settings/">ローカル エリア ネットワーク (LAN) の設定について</a><br><a href="../ProxySettings/">IE からみるプロキシの設定について</a><br><a href="../pac/">PAC について</a><br><strong>(今回の記事) WPAD について</strong></p><hr><p>今回は、お問い合わせいただくことが多い「プロキシの自動検出」について紹介します。</p><p>WPAD は、クライアントにプロキシの設定を自動配布するための方法として開発された技術です。</p><p>プロキシの設定はネットワーク管理者が DHCP サーバーや DNS サーバーに対して行います。クライアント (IE) 側では [設定を自動的に検出する] のチェックをオンにするだけで OK です。</p><p>これによりユーザーにプロキシ サーバー設定の手間をかけることなく、管理者がプロキシ サーバー経由の通信を管理できます。</p><p>[設定を自動的に検出する] のチェックがオンであると、IE はネットワーク管理者が DHCP サーバーや DNS サーバーに登録した自動構成スクリプトの宛先を「自動的に検出」して取得します。</p><p>そして、取得した自動構成スクリプトに記載された条件に従ってプロキシを利用します。</p><p>以下の順でスクリプトファイルの格納場所を検出します。</p><p>a. DHCP サーバーへ問い合わせ<br>b. DNS サーバーへ問い合わせ<br>c. NetBIOS 名を用いた問い合わせ</p><p>まず DHCP の “DHCPINFORM” プロトコルを使って自動構成スクリプトの URL を取得しようとします。</p><p>この取得に失敗した場合は、”wpad” というホスト名に対して HTTP 通信で “/wpad.dat” というファイルの取得を試みます。</p><p>wpad.dat というファイル名は固定ですが、ファイルの中身自体は一般的に .pac という拡張子が使われる自動構成スクリプトです。</p><p>ホスト名の解決は、DNS → NetBIOS の順に問合わせを行います。</p><p>DNS サーバーへの問い合わせは、具体的には以下の手順で行います。ここでは例として、クライアントのコンピュータ名が PC01.example.contoso.com とします。</p><p>i. <a href="http://wpad.example.contoso.com/wpad.dat" target="_blank" rel="noopener">http://wpad.example.contoso.com/wpad.dat</a> へ問い合わせを行う<br>ii. <a href="http://wpad.contoso.com/wpad.dat" target="_blank" rel="noopener">http://wpad.contoso.com/wpad.dat</a> へ問い合わせを行う</p><p>※ DHCP サーバーにて DHCPINFORM オプションが定義されていない場合のみ、DNS サーバーへの問い合わせを行います。DHCPINFORM オプションが定義されていた場合は、DNS サーバーへの問い合わせは行いません。</p><p>※ Windows 7 + Internet Explorer 11 の組み合わせでは、i. の問い合わせのみ行い、ii. の問い合わせは行いません。</p><hr><p>(※) NetBIOS 名を用いた問い合わせについて</p><p>中間者攻撃の脅威を低減するために、WPAD に関連した機能の動作変更が以下のセキュリティ更新プログラムにて行われています。</p><p>[MS16-077] WPAD のセキュリティ更新プログラムについて (2016 年 6 月 14 日)<br><a href="https://support.microsoft.com/ja-jp/help/3161949/" target="_blank" rel="noopener">https://support.microsoft.com/ja-jp/help/3161949/</a></p><p>セキュリティ更新プログラム適用以前は、WPAD の名前解決に DNS を利用している環境で、DNS の名前解決が失敗した場合でも NetBIOS を名前解決に利用する仕組みでした。 セキュリティ更新プログラム適用後は、更新プログラムで設定されるレジストリによって WPAD の名前解決に NetBIOS を使用しないようになります。 これにより、WPAD の名前解決が NetBIOS にフォールバックした際に、意図せず外部のネットワークへ到達することを制限し、WPAD の脆弱性を低減することを可能としています。</p><p>この動作変更により、WPAD 解決のために NetBIOS のみに依存している場合、失敗することがあります。 WPAD 解決のために NetBIOS の代わりに DHCP オプションまたは DNS を使用することをおすすめしますが、更新プログラム適用後の新しい既定の動作を変更するには、次のレジストリ エントリを作成します。</p><p>キー : HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\WinHttp<br>名前 : AllowOnlyDNSQueryForWPAD<br>種類 : REG_DWORD<br>値   : 0 (既定値 1)</p><hr><p>DHCP および DNS でスクリプト ファイルの場所が特定できない場合、NetBIOS 名を使用し「wpad.dat」ファイルの問い合わせを行います。</p><p>以下の弊社ブログにも情報がありますので、併せてご覧ください。</p><p>Insight WPAD proxy setting on IE<br><a href="https://docs.microsoft.com/en-us/archive/blogs/asiatech/insight-wpad-proxy-settings-on-ie" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/archive/blogs/asiatech/insight-wpad-proxy-settings-on-ie</a></p><p>また、プロキシ サーバーの設定については <a href="../LAN-Settings/">こちらの記事</a> をご覧ください。</p><hr><h2 id="DHCP-サーバーを使う方法"><a href="#DHCP-サーバーを使う方法" class="headerlink" title="DHCP サーバーを使う方法"></a>DHCP サーバーを使う方法</h2><p>DHCP サーバーに対してプロキシ設定の自動配布の設定を行うには、コード番号 252 の新しい種類のオプションを作成し、自動構成スクリプト ファイルの URL を設定します。</p><p>具体的な手順は以下をご覧ください。(ここでは Windows Server 2012 R2 の画面を例としていますが、これ以前のバージョンでも同様です)</p><img src="/blog/internet-explorer-microsoft-edge/wpad/DHCP01.png" class=""><p>上図のように、[IPv4] を右クリックし [既定のオプションの設定] をクリックします。</p><img src="/blog/internet-explorer-microsoft-edge/wpad/DHCP02.png" class=""><p>[既定のオプションと値] ダイアログで、[追加] ボタンをクリックします。</p><img src="/blog/internet-explorer-microsoft-edge/wpad/DHCP03.png" class=""><p>[名前] は、任意の文字列を入力します。<br>[データ型] は、”文字列” を選択します。<br>[コード] は、 252 と入力します。<br>[説明] は、任意の文字列を入力します。</p><p>入力後 [OK] ボタンをクリックします。</p><img src="/blog/internet-explorer-microsoft-edge/wpad/DHCP04.png" class=""><p>[既定のオプションと値] ダイアログに戻りますので、[オプション名] に今追加した コード 252 が選択されていることを確認し、[文字列] の部分に自動構成スクリプト ファイルの URL を入力します。</p><p>[OK] ボタンをクリックします。</p><img src="/blog/internet-explorer-microsoft-edge/wpad/DHCP05.png" class=""><p>[スコープ オプション] を右クリックし、[オプションの構成] をクリックします。</p><img src="/blog/internet-explorer-microsoft-edge/wpad/DHCP06.png" class=""><p>[スコープ オプション] ダイアログで、[全般] タブの [利用可能なオプション] から先ほど追加したコード 252 を選択します。</p><p>[文字列の値] に先ほど設定したものが表示されていることを確認し、[OK] ボタンをクリックします。</p><img src="/blog/internet-explorer-microsoft-edge/wpad/DHCP07.png" class=""><p>オプションに、コード 252 の設定ができたことを確認します。</p><hr><h2 id="DNS-サーバーを使う方法"><a href="#DNS-サーバーを使う方法" class="headerlink" title="DNS サーバーを使う方法"></a>DNS サーバーを使う方法</h2><p>DNS サーバーに対してプロキシ設定の自動配布の設定を行うには、まず、”wpad.dat” というファイル名で Web サーバーのルート ディレクトリに自動構成スクリプト ファイルを格納します。<br>次に、「wpad」という名前の DNS レコード (A レコードまたは CNAME レコード) を登録します。<br>以下に Windows Server 2012 R2 の画面での手順をまとめましたのでご参照ください。</p><img src="/blog/internet-explorer-microsoft-edge/wpad/DNS01.png" class=""><p>[前方参照ゾーン] に A レコードを追加します。</p><img src="/blog/internet-explorer-microsoft-edge/wpad/DNS02.png" class=""><p>[名前] には、”wpad” を入力します。<br>[IP アドレス] は、wpad.dat を配置した Web サーバーの IP アドレスを入力します。(この例では 192.168.1.1 としています)</p><hr><p>Windows Server 2008 から既定で wpad というホスト名の問い合わせを拒否します。</p><p>このため Windows Server 2008 以降で DNS を使用して WPAD を構成する場合は、以下の技術情報を参考にグローバル クエリ禁止リストを更新する必要があります。</p><p>Managing the Global Query Block List<br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc794902(v=ws.10)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc794902(v=ws.10)</a></p><p>Removing WPAD from DNS block list<br><a href="https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc441517(v=technet.10)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc441517(v=technet.10)</a></p><hr><h4 id="Smart-WPAD-について"><a href="#Smart-WPAD-について" class="headerlink" title="Smart WPAD について"></a>Smart WPAD について</h4><p>Windows 7 環境の IE8 以降では、Smart WPAD と呼ばれる機能があります。<br>Windows 7 より前の環境の IE では、WPAD による pac ファイルが『利用できない』ネットワーク環境においても [設定を自動的に検出する] が有効な場合に検出処理を行うため、IE 起動直後の初回のページ表示が遅いという報告が寄せられていました。</p><p>Smart WPAD の機能は処理の高速化のための機能であり、OS のネットワーク識別機能を利用し「WPAD により pac ファイルが取得できなかった環境」では同ネットワーク環境下において 30 日間検出を試みないようにするというものです。</p><p>Smart WPAD は、高速化のために、ネットワーク識別子ごとにかつての WPAD 解決結果を 30 日間保持する機能です。<br>解決結果には取得できなかった場合も含まれるので、”WPAD を使わない” という結果も保持されます。<br>WPAD 解決ができた場合は、解決した URL を保持します。<br>一度 WPAD が使用できないネットワークと判断された場合、そのネットワークに対して 30 日間は WPAD を使用しないように動作します。</p><hr><p>なお、本ブログは弊社の公式見解ではなく、予告なく変更される場合があります。<br>もし公式な見解が必要な場合は、弊社ドキュメント (<a href="https://docs.microsoft.com/" target="_blank" rel="noopener">https://docs.microsoft.com/</a> や <a href="https://support.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com</a>) をご参照いただく、もしくは私共サポートまでお問い合わせください。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;これまで Japan IE Support Team Blog にて公開していた記事のうち、プロキシ関連の記事を整理しました。&lt;br&gt;長い記事になってしまうため、下記の 4 つの記事に分けています。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../LAN-Settings/&quot;&gt;ローカ
      
    
    </summary>
    
    
    
      <category term="Internet Explorer" scheme="https://jpdsi.github.io/blog/tags/Internet-Explorer/"/>
    
      <category term="プロキシ" scheme="https://jpdsi.github.io/blog/tags/%E3%83%97%E3%83%AD%E3%82%AD%E3%82%B7/"/>
    
      <category term="pac" scheme="https://jpdsi.github.io/blog/tags/pac/"/>
    
      <category term="WPAD" scheme="https://jpdsi.github.io/blog/tags/WPAD/"/>
    
  </entry>
  
</feed>
